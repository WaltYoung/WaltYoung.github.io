{"meta":{"title":"WaltYoung","subtitle":"个人博客","description":"为世界上所有美好而战","author":"WaltYoung","url":"https://WaltYoung.github.io","root":"/"},"pages":[{"title":"电影","date":"2023-09-11T02:12:58.000Z","updated":"2023-09-12T11:12:34.357Z","comments":true,"path":"movies/index.html","permalink":"https://waltyoung.github.io/movies/index.html","excerpt":"","text":"let player = new Player({ \"id\": \"mse\", \"url\": \"https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/movies/%E9%B9%BF%E9%B8%A31024.mp4\", \"playsinline\": true, \"whitelist\": [ \"\" ], \"playbackRate\": [ 0.5, 1, 1.5, 2, 2.5, 3 ], \"thumbnail\": { \"pic_num\": 44, \"width\": 160, \"height\": 90, \"col\": 10, \"row\": 10, \"urls\": [ \"\" ] }, \"screenShot\": true, \"nativeTextTrack\": [ { \"src\": \"//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/byted-player-videos/1.0.0/textTrack-2.vtt\", \"label\": \"字幕2\", \"default\": false } ], \"keyShortcut\": \"on\" });"},{"title":"分类","date":"2023-06-15T15:45:28.000Z","updated":"2023-09-11T03:27:28.650Z","comments":true,"path":"categories/index.html","permalink":"https://waltyoung.github.io/categories/index.html","excerpt":"","text":""},{"title":"音乐","date":"2023-09-11T02:12:34.000Z","updated":"2024-01-23T12:12:55.345Z","comments":true,"path":"music/index.html","permalink":"https://waltyoung.github.io/music/index.html","excerpt":"","text":"​ ​ var demo = new APlayer ({ element: document.getElementById('demo'), showlrc: false, fixed: false, mini: false, audio: [ { title: '星辰大海', author: '黄霄雲', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%BB%84%E9%9C%84%E9%9B%B2%20-%20%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'Beautiful World', author: '宇多田光', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/Beautiful%20World%20-%20%E5%AE%87%E5%A4%9A%E7%94%B0%E5%85%89.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '残酷な天使のテーゼ', author: '高橋洋子', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%AB%98%E6%A9%8B%E6%B4%8B%E5%AD%90%20%28%E3%81%9F%E3%81%8B%E3%81%AF%E3%81%97%20%E3%82%88%E3%81%86%E3%81%93%29%20-%20%E6%AE%8B%E9%85%B7%E3%81%AA%E5%A4%A9%E4%BD%BF%E3%81%AE%E3%83%86%E3%83%BC%E3%82%BC%20%28Cruel%20Angel%27s%20Thesis%29%20%28Ambivalence%20Mix%29.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'One Last Kiss', author: '宇多田光', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/One%20Last%20Kiss%20-%20%E5%AE%87%E5%A4%9A%E7%94%B0%E5%85%89.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '花の塔', author: '酸欠さユり', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E8%8A%B1%E3%81%AE%E5%A1%94%20%28%E8%8A%B1%E4%B9%8B%E5%A1%94%29%20-%20%E9%85%B8%E6%AC%A0%E3%81%95%E3%83%A6%E3%82%8A.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '让风告诉你', author: '花玲、喵☆酱、宴宁、kinsen', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E8%AE%A9%E9%A3%8E%E5%91%8A%E8%AF%89%E4%BD%A0%20-%20%E8%8A%B1%E7%8E%B2%E3%80%81%E5%96%B5%E2%98%86%E9%85%B1%E3%80%81%E5%AE%B4%E5%AE%81%E3%80%81kinsen.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '我不曾忘记', author: '花玲、张安琪、沐霏', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%88%91%E4%B8%8D%E6%9B%BE%E5%BF%98%E8%AE%B0%20-%20%E8%8A%B1%E7%8E%B2%E3%80%81%E5%BC%A0%E5%AE%89%E7%90%AA%E3%80%81%E6%B2%90%E9%9C%8F.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '雪见·落入凡尘', author: '麦振鸿', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%BA%A6%E6%8C%AF%E9%B8%BF%20-%20%E9%9B%AA%E8%A7%81%C2%B7%E8%90%BD%E5%85%A5%E5%87%A1%E5%B0%98.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '飞鸟和蝉', author: '任然', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%A3%9E%E9%B8%9F%E5%92%8C%E8%9D%89%20-%20%E4%BB%BB%E7%84%B6.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '恋爱告急', author: '鞠婧祎', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%9E%A0%E5%A9%A7%E7%A5%8E%20-%20%E6%81%8B%E7%88%B1%E5%91%8A%E6%80%A5.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '青丝', author: '时光胶囊', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%9D%92%E4%B8%9D%20-%20%E6%97%B6%E5%85%89%E8%83%B6%E5%9B%8A.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '绿色', author: '陈雪凝', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%99%88%E9%9B%AA%E5%87%9D%20-%20%E7%BB%BF%E8%89%B2.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '九州同', author: '阿地力·阿不力孜、缪青、丁晓逵、牛建党', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%98%BF%E5%9C%B0%E5%8A%9B%C2%B7%E9%98%BF%E4%B8%8D%E5%8A%9B%E5%AD%9C%20_%20%E7%BC%AA%E9%9D%92%20_%20%E4%B8%81%E6%99%93%E9%80%B5%20_%20%E7%89%9B%E5%BB%BA%E5%85%9A%20-%20%E4%B9%9D%E5%B7%9E%E5%90%8C.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '蓄勢 ～GEAR UP～', author: '采风乐坊', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%87%87%E9%A3%8E%E4%B9%90%E5%9D%8A%20-%20%E8%93%84%E5%8B%A2%20%EF%BD%9EGEAR%20UP%EF%BD%9E.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'Way Back Home', author: '邓壬鑫', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E9%82%93%E5%A3%AC%E9%91%AB%20-%20Way%20Back%20Home%EF%BC%88%E4%B8%AD%E6%96%87%E6%B2%BB%E6%84%88%E7%89%88%EF%BC%89.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '无羁', author: '王一博', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%8E%8B%E4%B8%80%E5%8D%9A%20-%20%E6%97%A0%E7%BE%81.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'dududu', author: '咬人猫', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E5%92%AC%E4%BA%BA%E7%8C%AB%20-%20dududu.wav', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '起风了', author: '周深', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E5%91%A8%E6%B7%B1%20-%20%E8%B5%B7%E9%A3%8E%E4%BA%86.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'Rubia', author: '周深', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E5%91%A8%E6%B7%B1%20-%20Rubia.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '恋愛サーキュレーション', author: '花澤香菜', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%81%8B%E6%84%9B%E3%82%B5%E3%83%BC%E3%82%AD%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%20%28%E6%81%8B%E7%88%B1%E5%BE%AA%E7%8E%AF%29%20-%20%E8%8A%B1%E6%BE%A4%E9%A6%99%E8%8F%9C.flac', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '时间煮雨', author: '纯音乐', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%BA%AF%E9%9F%B3%E4%B9%90%20-%20%E6%97%B6%E9%97%B4%E7%85%AE%E9%9B%A8%20%28%E9%92%A2%E7%90%B4%E7%89%88%29.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '人类的光', author: '纯音乐', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%BA%AF%E9%9F%B3%E4%B9%90%20-%20%E4%BA%BA%E7%B1%BB%E7%9A%84%E5%85%89.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '夏天的风', author: '温岚', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%B8%A9%E5%B2%9A%20-%20%E5%A4%8F%E5%A4%A9%E7%9A%84%E9%A3%8E.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '探窗', author: '国风新语、浮生梦、汐音社', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%8E%A2%E7%AA%97%20-%20%E5%9B%BD%E9%A3%8E%E6%96%B0%E8%AF%AD%E3%80%81%E6%B5%AE%E7%94%9F%E6%A2%A6%E3%80%81%E6%B1%90%E9%9F%B3%E7%A4%BE.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '故人叹', author: '排骨教主、王胖子、西瓜JUN', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%8E%92%E9%AA%A8%E6%95%99%E4%B8%BB%20_%20%E7%8E%8B%E8%83%96%E5%AD%90%20_%20%E8%A5%BF%E7%93%9CJUN%20-%20%E6%95%85%E4%BA%BA%E5%8F%B9.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '烟雨行舟', author: '排骨教主', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%8E%92%E9%AA%A8%E6%95%99%E4%B8%BB%20-%20%E7%83%9F%E9%9B%A8%E8%A1%8C%E8%88%9F.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '辞九门回忆', author: '等什么君', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%AD%89%E4%BB%80%E4%B9%88%E5%90%9B%20-%20%E8%BE%9E%E4%B9%9D%E9%97%A8%E5%9B%9E%E5%BF%86.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '归寻', author: '等什么君', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%AD%89%E4%BB%80%E4%B9%88%E5%90%9B%20-%20%E5%BD%92%E5%AF%BB.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '叹郁孤', author: '等什么君', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%AD%89%E4%BB%80%E4%B9%88%E5%90%9B%20-%20%E5%8F%B9%E9%83%81%E5%AD%A4.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '关山酒', author: '等什么君', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%AD%89%E4%BB%80%E4%B9%88%E5%90%9B%20-%20%E5%85%B3%E5%B1%B1%E9%85%92.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'Lemon', author: '米津玄師', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E6%B8%A9%E5%B2%9A%20-%20%E5%A4%8F%E5%A4%A9%E7%9A%84%E9%A3%8E.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '四季予你', author: '程响', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E5%9B%9B%E5%AD%A3%E4%BA%88%E4%BD%A0%20-%20%E7%A8%8B%E5%93%8D.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '稻香', author: '周杰伦', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E7%A8%BB%E9%A6%99%20-%20%E5%91%A8%E6%9D%B0%E4%BC%A6.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '不问别离', author: '指尖笑', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E4%B8%8D%E9%97%AE%E5%88%AB%E7%A6%BB%20-%20%E6%8C%87%E5%B0%96%E7%AC%91.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'unravel', author: 'TK from 凛冽时雨', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/unravel%20-%20TK%20from%20%E5%87%9B%E5%86%BD%E6%97%B6%E9%9B%A8.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '幽霊東京', author: 'Ayase、初音未来', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/%E5%B9%BD%E9%9C%8A%E6%9D%B1%E4%BA%AC%20-%20Ayase%E3%80%81%E5%88%9D%E9%9F%B3%E6%9C%AA%E6%9D%A5.mp3', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: '最后的旅行', author: 'Rainton桐', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/Rainton%E6%A1%90%20-%20%E6%9C%80%E5%90%8E%E7%9A%84%E6%97%85%E8%A1%8C%EF%BC%88%E6%97%A5%E8%AF%AD%E5%89%A7%E6%83%85%E7%89%88%EF%BC%89.ogg', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' }, { title: 'Yoru ni Kakeru', author: 'Rainych、AVIAND', url: 'https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/music/Music/Yoru%20ni%20Kakeru%20-%20Rainych%E3%80%81AVIAND.mp4', pic: 'https://smms.app/image/fWkU7A6KvbeM5YB' } ] }); demo.init();"},{"title":"标签","date":"2023-06-15T15:38:57.000Z","updated":"2023-09-11T03:28:02.306Z","comments":true,"path":"tags/index.html","permalink":"https://waltyoung.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL-每月交易I","slug":"SQL-每月交易I","date":"2025-04-29T13:28:55.000Z","updated":"2025-04-29T15:13:40.929Z","comments":true,"path":"2025/04/29/SQL-每月交易I/","link":"","permalink":"https://waltyoung.github.io/2025/04/29/SQL-%E6%AF%8F%E6%9C%88%E4%BA%A4%E6%98%93I/","excerpt":"","text":"SQL-每月交易I原题链接:https://leetcode.cn/problems/monthly-transactions-i/description/?envType=study-plan-v2&envId=sql-free-50 Problem题目描述 Column Name Type id int country varchar state enum amount int trans_date date id 是这个表的主键。该表包含有关传入事务的信息。state 列类型为 [“approved”, “declined”] 之一。 编写一个 sql 查询来查找每个月和每个国家&#x2F;地区的事务数及其总金额、已批准的事务数及其总金额。 以 任意顺序 返回结果表。 输入例子 id country state amount trans_date 121 US approved 1000 2018-12-18 122 US declined 2000 2018-12-19 123 US approved 2000 2019-01-01 124 DE approved 2000 2019-01-07 输出例子 month country trans_count approved_count trans_total_amount approved_total_amount 2018-12 US 2 1 3000 1000 2019-01 US 1 1 2000 2000 2019-01 DE 1 1 2000 2000 Answer题目难度 简单 我的代码 123456789SELECT DATE_FORMAT(trans_date, &#x27;%Y-%m&#x27;) AS month, country, COUNT(*) AS trans_count, SUM(state = &#x27;approved&#x27;) AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = &#x27;approved&#x27;, amount, 0)) AS approved_total_amountFROM TransactionsGROUP BY DATE_FORMAT(trans_date, &#x27;%Y-%m&#x27;), country; 部分代码解释 SUM()作用是计算表中某列的所有数值之和，但在SUM()中使用布尔表达式可以用作计数，这涉及到在数值计算中的隐式转换。 以本题为例，假设有如下数据： state approved declined approved 对每条记录执行state = &#39;approved&#39; 第1条：approved &#x3D; approved → TRUE → 1 第2条：declined &#x3D; approved → FALSE → 0 第3条：approved &#x3D; approved → TRUE → 1 最终得到一个数值序列：[1, 0, 1] 对上述数值序列求和：SUM([1, 0, 1]) = 2。这实际上统计了满足条件的记录数 对比COUNT()的误区，COUNT()函数的作用是统计非NULL值的行数，故state = &#39;approved&#39;的返回结果永远是0或1（没有NULL）。 错误写法：COUNT(state = &#39;approved&#39;) COUNT(state = &#39;approved&#39;)实际统计的是总行数，与条件无关。 正确写法：COUNT(IF(state = &#39;approved&#39;, 1, NULL)) 如果想用COUNT()实现相同效果，需要结合IF()条件判断。这里的IF()会使得满足条件的行返回1，不满足条件的行返回NULL，而COUNT()会忽略NULL值。 为提升可读性，可以用COUNT(IF(state = &#39;approved&#39;, 1, NULL))替换SUM(state = &#39;approved&#39;)。在本题中，二者的效果一致。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://waltyoung.github.io/tags/SQL/"}]},{"title":"Linux上创建和使用交换文件的方法","slug":"Linux上创建和使用交换文件的方法","date":"2025-03-30T09:03:02.000Z","updated":"2025-03-30T12:03:53.116Z","comments":true,"path":"2025/03/30/Linux上创建和使用交换文件的方法/","link":"","permalink":"https://waltyoung.github.io/2025/03/30/Linux%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"Linux上创建和使用交换文件的方法前言 如上图所示，笔者的程序因占用了惊人的内存(265GB)被系统以Out of Memory的原因强制结束了进程。因服务器不可轻易重启，遂有此文。 正文检查交换空间可通过swapon --show命令检查 Linux 交换空间大小 1234swapon --showNAME TYPE SIZE USED PRIO/dev/nvme0n1p2 partition 128G 5.8G -2/swapfile file 256G 0B -3 swapon命令会告诉你是真实的交换分区还是交换文件。partition表示交换分区，file 表示交换文件 创建交换文件使用fallocate命令创建大小为 1GB 的文件。swapfile为交换文件的名称，可以是任意的。 1sudo fallocate -l 1G /swapfile 建议只允许 root 用户读写该交换文件。否则尝试将此文件用于交换区域时，会看到类似“不安全权限 0644，建议 0600”的警告。 1sudo chmod 600 /swapfile 使用mkswap命令将新文件标记为交换文件 1sudo mkswap /swapfile 使用swapon命令启用该交换文件 1sudo swapon /swapfile 持久化上文所述操作暂时的。重新启动系统，上述所有更改都将消失。故如需要保存更改，则应将新创建的交换文件添加到/etc/fstab文件 对配置文件进行任何更改之前，最好先进行备份。 1sudo cp /etc/fstab /etc/fstab.back 将以下行添加到/etc/fstab文件的末尾 1/swapfile none swap sw 0 0 使用命令行文本编辑器手动操作，或者使用以下命令 1echo &#x27;/swapfile none swap sw 0 0&#x27; | sudo tee -a /etc/fstab 修改交换文件的大小关闭交换文件 1sudo swapoff /swapfile 使用fallocate命令将其大小更改为 2GB 。 1sudo fallocate -l 1G /swapfile 使用mkswap命令再次将文件标记为交换文件 1sudo mkswap /swapfile 使用swapon命令再次启用该交换文件 1sudo swapon /swapfile 删除交换文件当你要求系统停止使用交换文件时，系统会将所有内存页(Page)传输回内存。所以建议读者应该有足够的空闲内存，然后再停止使用交换文件。 关闭交换文件 1sudo swapoff /swapfile 下一步是从/etc/fstab文件中删除相应的条目。 最后，删除该文件以释放空间 1sudo rm /swapfile 写在文后调整 swappiness 参数swappiness参数决定了交换空间的使用频率。swappiness值的范围从 0 到 100。较高的值意味着交换空间将被更频繁地使用。 Ubuntu 桌面的默认的swappiness是 60，而服务器的默认swappiness是 1。可以使用以下命令查看swappiness的值 1cat /proc/sys/vm/swappiness 使用以下系统命令动态更改swappiness 1sudo sysctl vm.swappiness=25 上述修改是临时的。如果要使其永久化，可以编辑/etc/sysctl.conf文件，并在文件末尾添加swappiness 值:vm.swappiness=25","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"}]},{"title":"记一次R45G项目的Code Review","slug":"记一次R45G项目的Code-Review","date":"2025-01-10T10:35:34.000Z","updated":"2025-01-10T10:58:39.830Z","comments":true,"path":"2025/01/10/记一次R45G项目的Code-Review/","link":"","permalink":"https://waltyoung.github.io/2025/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1R45G%E9%A1%B9%E7%9B%AE%E7%9A%84Code-Review/","excerpt":"","text":"记一次R45G项目的Code Review事件的起因是笔者参加了B站UP主码农高天的Code Review。他已经成为Python core dev，因而记录一下他提出的建议。 视频链接：https://www.bilibili.com/video/BV19XSkY3E6G/?spm_id_from&#x3D;333.1387.homepage.video_card.click&amp;vd_source&#x3D;97cb8ac6d0f997c83d7c05f90d5ece5c 项目地址：https://github.com/WaltYoung/RecognizeEncryptedTrafficBasedOnMachineLearning 修改建议1.项目名不应过长，较长的项目名可以写在About描述中，Github仓库名可以缩写，即使用英文首字母。 2.__pycache__等无关文件与目录或敏感信息，应该被写入.gitignore文件中。.gitignore文件支持通配符，以下是一个.gitignore文件的简单示例。 1234/.vscode/.idea/__pycache__/build 3.加入if __name__ == &#39;__main__&#39;:。因为部分代码可能是这个文件作为module被import时必须执行的，而部分代码仅在这个文件被作为脚本时需要执行的；可以帮助定位文件的入口。 4.无关变量在代码完成后应及时清理，使用pylance等插件会提醒开发者。 5.如果在外层if中只包含一个内层if，在无关顺序、不影响可读性的条件下，应该合并2层if。 6.类型标注。Python作为一门动态类型语言，运行时不需要指定变量类型。但由于不知道参数的类型，所以会给多人协作和后期维护带来阻碍。在Python 3.5及以后，支持Type Hints，即类型提示。使用Type Hints需要导入typing模块。 1from typing import List, Tuple, Set, Dict, ClassVar 不使用 Type Hints 12345def add_numbers(a, b): return a + b result = add_numbers(10, 5)print(result) 使用 Type Hints 12345def add_numbers(a: int, b: int) -&gt; int: return a + b result = add_numbers(10, 5)print(result) 使用Type Hints后，静态类型检查工具（如MyPy）可以在代码运行前捕获潜在的类型错误。类型提示还可以用于自动生成文档，使得API更加清晰。 7.不要在局部函数内，不必要地使用全局变量，而应该使用参数传入，否则会造成函数的耦合性非常强。 8.善用any、all等python内置函数 12345def findIndex(value): for stream in streams: if stream.tcp_stream == value: return True return False 如以上代码可以被优化为以下代码 12def findIndex(value): return any(stream.tcp_stream == value for stream in streams) Python内置函数 12345678910111213141516171819202122232425262728293031321. 基本类型转换和数值操作 int(): 将一个数字或字符串转换为整数。 float(): 将一个数字或字符串转换为浮点数。 str(): 将对象转换为字符串。 max(): 返回可迭代对象中的最大值。 min(): 返回可迭代对象中的最小值。 2. 序列操作 len(): 返回对象的长度（元素数量）。 list(): 将可迭代对象转换为列表。 tuple(): 将可迭代对象转换为元组。 set(): 将可迭代对象转换为集合。 dict(): 创建一个字典。 3. 函数与迭代 sum(): 返回可迭代对象中所有元素的总和。 sorted(): 返回一个排序的列表。 reversed(): 返回一个反向迭代器。 enumerate(): 返回一个构建了索引的可迭代对象。 4. 逻辑操作 any(): 如果可迭代对象中任一元素为真，返回 True。 all(): 如果可迭代对象中所有元素都为真，返回 True。 5. 对象类型与检查 type(): 返回对象的类型。 isinstance(): 检查一个对象是否是特定类的实例。 6. 其他实用函数 map(): 对可迭代对象中的每个元素应用指定的函数。 filter(): 过滤可迭代对象，返回满足条件的元素。 zip(): 将多个可迭代对象打包成一个元组的可迭代对象。 9.类名首字母大写。 10.类的名字与变量的名字不应重复 11.对于经典class的定义，可以使用dataclass库进行优化。 12345class Stream: def __init__(self, tcp_stream, sni, length): self.tcp_stream = tcp_stream self.sni = sni self.tcp_length = length 如以上代码可以被优化为以下代码 1234567from dataclasses import dataclass @dataclass class Stream: tcp_stream: str sni: str tcp_length: int 使用dataclass库可以让代码更加简洁，并且自动生成一些常用的方法，比如 __init__和__repr__。同时，通过类型注解明确了每个属性的数据类型。 12.在输出数据之前，将数据保存为最便于处理的方式。最后再考虑输出格式。 13.用户需要修改的configuration应该在同一个文件中完成。","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"https://waltyoung.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"记一次XXX","slug":"记一次XXX","permalink":"https://waltyoung.github.io/tags/%E8%AE%B0%E4%B8%80%E6%AC%A1XXX/"},{"name":"Python","slug":"Python","permalink":"https://waltyoung.github.io/tags/Python/"},{"name":"Code Review","slug":"Code-Review","permalink":"https://waltyoung.github.io/tags/Code-Review/"}]},{"title":"Linux(ubuntu) + Firefox + selenium 教程","slug":"Linux-ubuntu-Firefox-selenium-教程","date":"2024-05-08T08:27:56.000Z","updated":"2024-05-08T08:32:16.195Z","comments":true,"path":"2024/05/08/Linux-ubuntu-Firefox-selenium-教程/","link":"","permalink":"https://waltyoung.github.io/2024/05/08/Linux-ubuntu-Firefox-selenium-%E6%95%99%E7%A8%8B/","excerpt":"","text":"Linux(ubuntu) + Firefox + selenium 教程环境:ubuntu 22.04 + Firefox 124.0.2 + GeckoDriver 0.34.0 + selenium 3.141.0 Firefox 配置第1步：下载 Firefoxubuntu 自带的 Firefox 是通过snap安装的，驱动该 Firefox 会报错Your Firefox profile cannot be loaded. It may be missing or inaccessible，故需要重新下载 Firefox 下载地址：https://releases.mozilla.org/pub/firefox/releases/ 第2步：解压到指定目录注意替换文件名 1sudo tar -xjvf firefox-124.0.2.tar.bz2 -C /usr/lib/ 第3步：修改owner1sudo chown -R root:root /usr/lib/firefox 第4步：删除原先的link1sudo unlink /usr/bin/firefox 如果报错“不存在链接”，则可以忽略，进行下一步 第5步：建立新的软链接1sudo ln -s /usr/lib/firefox/firefox /usr/bin/firefox GeckoDriver 配置第6步：下载对应版本的 GeckoDriverGeckoDriver 下载地址：https://github.com/mozilla/geckodriver/releases/ 如果读者不知道 Firefox 对应 GeckoDriver 的版本号，可通过以下链接查看：https://firefox-source-docs.mozilla.org/testing/geckodriver/Support.html 第7步：解压17z x geckodriver-v0.34.0-linux64.tar.gz 第8步：赋予执行权限1chmod +x geckodriver 第9步：复制到指定目录注意替换文件名 1sudo cp geckodriver /usr/local/bin/ selenium 配置第10步：下载 selenium1pip install selenium 测试在终端中输入python3 在 python 控制台输入以下代码以测试 12from selenium import webdriverdriver = webdriver.Firefox() Debug如果读者依然遇到 FireFox 报错Your Firefox profile cannot be loaded. It may be missing or inaccessible或在切换用户后遇到该报错，可以尝试以下操作 首先，进入home下对应的用户目录，如/home/raidenmei。在终端中输入以下命令，注意username和usergroup需要替换为实际的用户名和用户组。一般情况下，二者相同。 12sudo chown -R username:usergroup .mozillasudo chown -R username:usergroup .cache 写在文后笔者这一路上踩坑无数，综合多篇文章，总结以上内容，希望能帮到读者。 可选择关闭 Firefox 自动更新，避免频繁升级导致自动化测试失败 关闭 Firefox 自动更新在Firefox里面输入about:config，将app.update.auto变量置为false","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"},{"name":"Selenium","slug":"Selenium","permalink":"https://waltyoung.github.io/tags/Selenium/"}]},{"title":"Linux Go环境配置","slug":"Linux-Go环境配置","date":"2024-05-04T10:07:24.000Z","updated":"2024-05-04T11:35:49.102Z","comments":true,"path":"2024/05/04/Linux-Go环境配置/","link":"","permalink":"https://waltyoung.github.io/2024/05/04/Linux-Go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Linux Go环境配置前言因apt或apt-get包管理工具的Go语言包更新缓慢，snap包管理工具安装的Go语言包可能存在未知问题，故本文适合需要较高版本的Go语言环境，但apt或apt-get等包管理工具未提供的情况。（笔者写下此文时是2024-05-04，apt或apt-get等包管理工具的Go语言包更新到1.18版本，但笔者需要1.21.5版本，故有此文） Golang环境配置第0步：系统更新切换到root用户，并且注意全程使用root用户 1su 更新软件包列表 1apt-get update 进行一次升级 1apt-get upgrade 第1步：下载可前往https://go.dev/dl/下载 或可通过wget工具下载 1wget https://go.dev/dl/go1.21.5.linux-amd64.tar.gz 第2步：解压到指定目录注意替换文件名 1tar -xzf firefox-124.0.2.tar.bz2 -C /usr/lib/ 第3步：建立软链接1ln -s /usr/lib/firefox/firefox /usr/bin/firefox 第4步：修改配置文件修改全局配置文件/etc/profile为每个用户启用Go环境 在/etc/profile文件中加入以下内容 123export GOPATH=/usr/local/gopathexport GOROOT=/usr/local/goexport PATH=$GOROOT/bin:$PATH 第5步：使配置文件生效1source /etc/profile 第6步：查看Go环境变量1go env 若正常输出则表明配置成功 第7步：修改Go环境变量12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct GO111MODULE建议1.13版本后的Go环境开启GOPROXY用于绕过长城，减少下载时间 Goland配置未完待续 Vs Code配置因为Goland该IDE收费，Linux下破解较为麻烦，故配置Vs Code便于敲代码 下载扩展在左边的工具栏中点击Extensions图标，在搜索框中输入Go，然后从搜索结果中找到 Go并点击Install。这个插件由 Go 团队开发，它提供了对 Go 语言的智能感知、重构和代码导航支持。 手动安装模块在终端中输入以下命令 123go install -v golang.org/x/tools/gopls@latestgo install -v github.com/go-delve/delve/cmd/dlv@latestgo install honnef.co/go/tools/cmd/staticcheck@latest 在Vs Code中编辑第一个go文件触发安装,可以点击Install安装gopls，也可以点击Install All连同go-delve等一起安装。go-delve是Go语言的调试利器，建议安装。staticcheck是Go语言的语法检查器，建议安装。 运行创建一个名为main.go的文件，并将以下代码保存在其中。**包名必须为 main **，文件名可自定义 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\\n&quot;)&#125; 初始化项目，将在项目根目录下生成一个新的go.mod文件，该文件描述了项目依赖 1go mod init main 运行main.go文件 1go run main.go 写在文后笔者一路踩坑，综合多篇文章，总结以上内容，希望能帮到读者。将在后续补完 Goland 的配置","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"},{"name":"Go","slug":"Go","permalink":"https://waltyoung.github.io/tags/Go/"}]},{"title":"ACM-圣诞歌","slug":"ACM-圣诞歌","date":"2024-03-21T13:46:37.000Z","updated":"2024-03-21T13:48:35.386Z","comments":true,"path":"2024/03/21/ACM-圣诞歌/","link":"","permalink":"https://waltyoung.github.io/2024/03/21/ACM-%E5%9C%A3%E8%AF%9E%E6%AD%8C/","excerpt":"","text":"ACM-圣诞歌原题链接:无(笔者参加了ACM校赛，但被一题简单题卡住，过了样例但无法AC。赛后经朋友恶霸提醒修正了代码) Problem题目描述 输入描述 输入一个整数n，n属于[1,1000]区间，代表一首圣诞歌中包含的字符串总数。紧接着输入n行字符串。每个字符串长度不大于100。 输出描述 如果没有字符串满足要求，输出-1。否则先输出m，代表其中有m个合法的字符串。之后输出m行字符串，按平均ASCII码升序排序，如果平均ASCII码相同的字符串，按字典序升序排序（字典序排序：两个字符串，从前往后对比，找到第一个不同字母，这个字母小的字符串字典序小） 输入例子1 3A2#89wrupiysandi$78!oA2#89wrupa 输出例子1 2A2#89wrupaA2#89wrupi 输入例子2 312wwsAsnks23449op@1xf234sfg 输出例子2 -1 Answer题目难度 简单 解题算法 字符串排序(笔者借助运算符重载后的**快排函数sort()**实现的排序算法) 我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt; using namespace std;typedef struct&#123; string str; int num;&#125;sing;bool operator &lt; (sing a,sing b)//运算符重载&#123; if(a.num &lt; b.num) return true; else if(a.num == b.num) &#123; int mini; mini=min(strlen(a.str.c_str()),strlen(b.str.c_str()));//对于一个字符串，使用sizeof将会返回整个字符串在内存中所占的字节数，包括末尾的空字符\\0；而使用strlen将会返回字符串的实际长度，不包括末尾的空字符\\0 for(int i=0;i&lt;mini;i++) &#123; if(a.str[i] == b.str[i]) continue; return a.str[i] &lt; b.str[i]; &#125; &#125; else return false;&#125;int main()&#123; int t; cin &gt;&gt; t; sing a[1010]; int n=0; while(t--) &#123; string str; cin &gt;&gt; str; if(!isalpha(str[0])) continue; if(strlen(str.c_str()) &lt; 8 || strlen(str.c_str()) &gt; 20) continue; int small,big,digital,special; small=0; big=0; digital=0; special=0; for(int i=0;i&lt;strlen(str.c_str());i++) &#123; if(str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) small=1; if(str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) big=1; if(str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) digital=1; if(str[i] == &#x27;~&#x27; || str[i] == &#x27;!&#x27; || str[i] == &#x27;@&#x27; || str[i] == &#x27;#&#x27; || str[i] == &#x27;$&#x27;) special=1; &#125; if(small != 1 || big != 1 || digital != 1 || special != 1) continue; int sum=0; for(int i=0;i&lt;strlen(str.c_str());i++) sum += str[i]; double ave; ave = (double)sum / strlen(str.c_str()); ave = floor(ave); if( !(ave &gt;= 65 &amp;&amp; ave &lt;= 122) ) continue; a[n].num=(int)ave; a[n].str=str; n++; &#125; if(n == 0) &#123; cout &lt;&lt; &quot;-1&quot; &lt;&lt;endl; return 0; &#125; sort(a,a+n); cout &lt;&lt; n &lt;&lt;endl; for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].str &lt;&lt;endl; return 0;&#125; 此题较为简单，赛时没有AC的原因是使用了sizeof求字符串长度，这是错误的。因为sizeof将会返回整个字符串在内存中所占的字节数，包括末尾的空字符\\0，所以应该使用strlen()或.length()求字符串长度，strlen将会返回字符串的实际长度，不包括末尾的空字符\\0。如需复习字符串的函数，可以参考笔者的这篇文章https://waltyoung.github.io/2023/10/31/PAT-Dating/ 关键代码 123456789101112131415161718bool operator &lt; (sing a,sing b)//运算符重载&#123; if(a.num &lt; b.num)//平均ASCII码的值较小的字符串排在前面 return true; else if(a.num == b.num)若平均ASCII码的值相等，则逐个比较字符串的字典序 &#123; int mini; mini=min(strlen(a.str.c_str()),strlen(b.str.c_str()));//得到2个字符串的最短长度 for(int i=0;i&lt;mini;i++) &#123; if(a.str[i] == b.str[i])//若当前字符的字典序相等，则比较下一个字符 continue; return a.str[i] &lt; b.str[i];//字典序较小的字符串排在前面 &#125; &#125; else return false;&#125;","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"},{"name":"PAT","slug":"PAT","permalink":"https://waltyoung.github.io/tags/PAT/"},{"name":"ACM","slug":"ACM","permalink":"https://waltyoung.github.io/tags/ACM/"}]},{"title":"文件头文件尾总结","slug":"文件头文件尾总结","date":"2023-11-07T12:49:29.000Z","updated":"2023-11-07T12:50:40.778Z","comments":true,"path":"2023/11/07/文件头文件尾总结/","link":"","permalink":"https://waltyoung.github.io/2023/11/07/%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B0%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"文件头文件尾总结 文件类型 文件头 文件尾 JPEG (jpg) FF D8 FF FF D9 PNG (png) 89 50 4E 47 AE 42 60 82 GIF (gif) 47 49 46 38 00 3B ZIP Archive (zip) 50 4B 03 04 50 4B TIFF (tif) 49 49 2A 00 Windows Bitmap (bmp) 42 4D CAD (dwg) 41 43 31 30 Adobe Photoshop (psd) 38 42 50 53 Rich Text Format (rtf) 7B 5C 72 74 XML (xml) 3C 3F 78 6D HTML (html) 68 74 6D 6C 3E Email [thorough only] (eml) 44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A Outlook Express (dbx) CF AD 12 FE C5 FD 74 6F Outlook (pst) 21 42 44 4E MS Word&#x2F;Excel (xls.or.doc) D0 CF 11 E0 MS Access (mdb) 53 74 61 6E 64 61 72 64 20 4A WordPerfect (wpd) FF 57 50 43 Adobe Acrobat (pdf) 25 50 44 46 2D 31 2E Quicken (qdf) AC 9E BD 8F Windows Password (pwl) E3 82 85 96 RAR Archive (rar) 52 61 72 21 Wave (wav) 57 41 56 45 AVI (avi) 41 56 49 20 Real Audio (ram) 2E 72 61 FD Real Media (rm) 2E 52 4D 46 MPEG (mpg) 00 00 01 BA MPEG (mpg) 00 00 01 B3 Quicktime (mov) 6D 6F 6F 76 Windows Media (asf) 30 26 B2 75 8E 66 CF 11 MIDI (mid) 4D 54 68 64","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"}]},{"title":"Python反编译之exe文件反编译","slug":"Python反编译之exe文件反编译","date":"2023-11-06T00:27:27.000Z","updated":"2023-11-06T00:28:46.615Z","comments":true,"path":"2023/11/06/Python反编译之exe文件反编译/","link":"","permalink":"https://waltyoung.github.io/2023/11/06/Python%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bexe%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"Python反编译之exe文件反编译在学习反编译之前，先学习编译 编译pyinstaller是一个第三方库，支持 Python 2.7 和 Python 3.3+。可以在 Windows、Mac OS X和Linux上使用，但不跨平台，即编译为.exe文件，需要在 Windows系统上进行；编译为mac app，需要在Mac OS上进行。 安装方法： 1pip install pyinstaller 编译产生单个的可执行文件，在生成的dist文件夹中可以找到.exe文件 1pyinstaller -F -w 文件名.py 参数解释： -F 产生单个的可执行文件 -w 指定程序运行时不显示命令行窗口（仅对 Windows 有效) 其他参数或选项在使用到时再作补充 注：（可能存在的问题） 1、可执行文件过大（比如输出helloworld的程序占用2G） 原因：利用 PyInstaller 对指定的代码进行解释时，会保存所有的依赖项，包括 import引用的库和Python解析器。 解决方法：在引用包时，尽量使用from ... import ...语句，而不是直接使用import导入整个库 2、双击可执行文件一闪而过 原因：程序设计者没有编写GUI 解决方法：如下有3种方法 在程序末尾使用input()函数捕捉输入，主动输入以结束程序 在命令行下运行.exe文件 导入os模块，在程序末尾添加os.system(&quot;pause&quot;)来防止控制台关闭 反编译工具：uncompyle6 安装方法：直接下载https://sourceforge.net/projects/pyinstallerextractor/ 命令：**(需要把pyinstxtractor.py和.exe文件置于同一目录)** 1python pyinstxtractor.py 文件名.exe 命令执行后可以发现一个名为文件名.exe_extracted的文件夹，在其中可以发现与.exe文件同名的pyc文件。 经过该方法生成的pyc文件是没有Magic Number的，需要根据本地的Python版本自行补全 因为笔者本地的Python版本是Python 3.9.13，故只有Python 1.5至Python 3.9.13的Magic Number。在C:\\Users\\86159\\AppData\\Local\\Programs\\Python\\Python39\\Lib\\importlib\\_bootstrap_external.py该路径下可以得到本地的Python版本已有Magic Number。读者需要自行替换为Python解释器所在的路径。 Magic Number表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113Known values: Python 1.5: 20121 Python 1.5.1: 20121 Python 1.5.2: 20121 Python 1.6: 50428 Python 2.0: 50823 Python 2.0.1: 50823 Python 2.1: 60202 Python 2.1.1: 60202 Python 2.1.2: 60202 Python 2.2: 60717 Python 2.3a0: 62011 Python 2.3a0: 62021 Python 2.3a0: 62011 (!) Python 2.4a0: 62041 Python 2.4a3: 62051 Python 2.4b1: 62061 Python 2.5a0: 62071 Python 2.5a0: 62081 (ast-branch) Python 2.5a0: 62091 (with) Python 2.5a0: 62092 (changed WITH_CLEANUP opcode) Python 2.5b3: 62101 (fix wrong code: for x, in ...) Python 2.5b3: 62111 (fix wrong code: x += yield) Python 2.5c1: 62121 (fix wrong lnotab with for loops and storing constants that should have been removed) Python 2.5c2: 62131 (fix wrong code: for x, in ... in listcomp/genexp) Python 2.6a0: 62151 (peephole optimizations and STORE_MAP opcode) Python 2.6a1: 62161 (WITH_CLEANUP optimization) Python 2.7a0: 62171 (optimize list comprehensions/change LIST_APPEND) Python 2.7a0: 62181 (optimize conditional branches: introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE) Python 2.7a0 62191 (introduce SETUP_WITH) Python 2.7a0 62201 (introduce BUILD_SET) Python 2.7a0 62211 (introduce MAP_ADD and SET_ADD) Python 3000: 3000 3010 (removed UNARY_CONVERT) 3020 (added BUILD_SET) 3030 (added keyword-only parameters) 3040 (added signature annotations) 3050 (print becomes a function) 3060 (PEP 3115 metaclass syntax) 3061 (string literals become unicode) 3071 (PEP 3109 raise changes) 3081 (PEP 3137 make __file__ and __name__ unicode) 3091 (kill str8 interning) 3101 (merge from 2.6a0, see 62151) 3103 (__file__ points to source file) Python 3.0a4: 3111 (WITH_CLEANUP optimization). Python 3.0b1: 3131 (lexical exception stacking, including POP_EXCEPT 3021) Python 3.1a1: 3141 (optimize list, set and dict comprehensions: change LIST_APPEND and SET_ADD, add MAP_ADD #2183) Python 3.1a1: 3151 (optimize conditional branches: introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE 4715) Python 3.2a1: 3160 (add SETUP_WITH #6101) tag: cpython-32 Python 3.2a2: 3170 (add DUP_TOP_TWO, remove DUP_TOPX and ROT_FOUR #9225) tag: cpython-32 Python 3.2a3 3180 (add DELETE_DEREF #4617) Python 3.3a1 3190 (__class__ super closure changed) Python 3.3a1 3200 (PEP 3155 __qualname__ added #13448) Python 3.3a1 3210 (added size modulo 2**32 to the pyc header #13645) Python 3.3a2 3220 (changed PEP 380 implementation #14230) Python 3.3a4 3230 (revert changes to implicit __class__ closure #14857) Python 3.4a1 3250 (evaluate positional default arguments before keyword-only defaults #16967) Python 3.4a1 3260 (add LOAD_CLASSDEREF; allow locals of class to override free vars #17853) Python 3.4a1 3270 (various tweaks to the __class__ closure #12370) Python 3.4a1 3280 (remove implicit class argument) Python 3.4a4 3290 (changes to __qualname__ computation #19301) Python 3.4a4 3300 (more changes to __qualname__ computation #19301) Python 3.4rc2 3310 (alter __qualname__ computation #20625) Python 3.5a1 3320 (PEP 465: Matrix multiplication operator #21176) Python 3.5b1 3330 (PEP 448: Additional Unpacking Generalizations #2292) Python 3.5b2 3340 (fix dictionary display evaluation order #11205) Python 3.5b3 3350 (add GET_YIELD_FROM_ITER opcode #24400) Python 3.5.2 3351 (fix BUILD_MAP_UNPACK_WITH_CALL opcode #27286) Python 3.6a0 3360 (add FORMAT_VALUE opcode #25483) Python 3.6a1 3361 (lineno delta of code.co_lnotab becomes signed #26107) Python 3.6a2 3370 (16 bit wordcode #26647) Python 3.6a2 3371 (add BUILD_CONST_KEY_MAP opcode #27140) Python 3.6a2 3372 (MAKE_FUNCTION simplification, remove MAKE_CLOSURE #27095) Python 3.6b1 3373 (add BUILD_STRING opcode #27078) Python 3.6b1 3375 (add SETUP_ANNOTATIONS and STORE_ANNOTATION opcodes #27985) Python 3.6b1 3376 (simplify CALL_FUNCTIONs &amp; BUILD_MAP_UNPACK_WITH_CALL 27213) Python 3.6b1 3377 (set __class__ cell from type.__new__ #23722) Python 3.6b2 3378 (add BUILD_TUPLE_UNPACK_WITH_CALL #28257) Python 3.6rc1 3379 (more thorough __class__ validation #23722) Python 3.7a1 3390 (add LOAD_METHOD and CALL_METHOD opcodes #26110) Python 3.7a2 3391 (update GET_AITER #31709) Python 3.7a4 3392 (PEP 552: Deterministic pycs #31650) Python 3.7b1 3393 (remove STORE_ANNOTATION opcode #32550) Python 3.7b5 3394 (restored docstring as the first stmt in the body; this might affected the first line number #32911) Python 3.8a1 3400 (move frame block handling to compiler #17611) Python 3.8a1 3401 (add END_ASYNC_FOR #33041) Python 3.8a1 3410 (PEP570 Python Positional-Only Parameters #36540) Python 3.8b2 3411 (Reverse evaluation order of key: value in dict comprehensions #35224) Python 3.8b2 3412 (Swap the position of positional args and positional only args in ast.arguments #37593) Python 3.8b4 3413 (Fix &quot;break&quot; and &quot;continue&quot; in &quot;finally&quot; #37830) Python 3.9a0 3420 (add LOAD_ASSERTION_ERROR #34880) Python 3.9a0 3421 (simplified bytecode for with blocks #32949) Python 3.9a0 3422 (remove BEGIN_FINALLY, END_FINALLY, CALL_FINALLY, POP_FINALLY bytecodes #33387) Python 3.9a2 3423 (add IS_OP, CONTAINS_OP and JUMP_IF_NOT_EXC_MATCH bytecodes #39156) Python 3.9a2 3424 (simplify bytecodes for *value unpacking) Python 3.9a2 3425 (simplify bytecodes for **value unpacking) pyc文件结构 注：不同的版本的Magic Number都在 Python&#x2F;import.c 内定义 Python3.7及以上版本中，头部包含4字节的Magic Number、4字节的空位、4字节的时间戳以及4字节的文件大小信息 Python3.3 至 Python3.7版本中，头部包含4字节的Magic Number、4字节的时间戳以及4字节的文件大小信息 Python3.3 以下的版本中，头部包含4字节的Magic Number、4字节的时间戳 其后是序列化的PyCodeObject(此结构在Include/code.h内定义)，序列化方法在 Python/marshal.c内定义 参考链接：https://kdr2.com/tech/python/pyc-format.html 以本地的Python版本为例，下图是4字节的Magic Number和4字节的空位 下图是4字节的时间戳和4字节的文件大小信息 在Magic Number、空位、时间戳以及文件大小信息中，后三者对文件反编译没有影响，全部填充0即可。而因为小端序和 Python 版本的原因，Magic Number时常只需要修改第一个字节即可。如某Python 3.8版本的Magic Number是0A0D0D61，笔者本地的Python 3.9版本的Magic Number是0A0D0D55。 接下来就是反编译Python的字节码文件（pyc文件） 关于pyc文件反编译更多的信息，请阅读笔者的另一篇笔记https://waltyoung.github.io/2023/11/05/Python%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bpyc%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"Python","slug":"Python","permalink":"https://waltyoung.github.io/tags/Python/"}]},{"title":"Python反编译之pyc文件反编译","slug":"Python反编译之pyc文件反编译","date":"2023-11-05T13:42:12.000Z","updated":"2023-11-05T13:43:40.711Z","comments":true,"path":"2023/11/05/Python反编译之pyc文件反编译/","link":"","permalink":"https://waltyoung.github.io/2023/11/05/Python%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bpyc%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"Python反编译之pyc文件反编译笔者在做CTF逆向题时遇到了pyc文件，IDA无法处理，遂有了此文 pyc文件简介python文件在被import运行的时候会在同目录下编译一个pyc的文件（为了下次快速加载），这个文件可以和py文件一样使用，但无法阅读和修改。pyc是一种二进制文件，是由py文件经过编译后，生成的可执行的字节码文件。pyc文件是可以跨平台部署的，类似Java的.class文件。 编译生成pyc文件方法一编译时使用-m py_compile选项 1python -m py_compile test.py 使用-O选项，可以将.pyc文件优化为.pyo文件（体积更小） 1python -O -m py_compile test.py 方法一使用代码编译生成 12import py_compilepy_compile.compile(r&#x27;test.py&#x27;) 参考链接：https://blog.csdn.net/qq_33957603&#x2F;article&#x2F;details&#x2F;126929263 pyc文件结构注：不同的版本的Magic Number都在 Python&#x2F;import.c 内定义 Python3.7及以上版本中，头部包含4字节的Magic Number、4字节的空位、4字节的时间戳以及4字节的文件大小信息，后者对文件反编译没有影响，全部填充0即可 Python3.3 至 Python3.7版本中，头部包含4字节的Magic Number、4字节的时间戳以及4字节的文件大小信息 Python3.3 以下的版本中，头部包含4字节的Magic Number、4字节的时间戳 其后是序列化的PyCodeObject(此结构在Include/code.h内定义)，序列化方法在 Python/marshal.c内定义 参考链接：https://kdr2.com/tech/python/pyc-format.html 以本地的Python版本为例，下图是4字节的Magic Number和4字节的空位 下图是4字节的时间戳和4字节的文件大小信息 逆向方法方法一工具：pycdc pycdc 用于 Python 3.9及更高版本 安装方法： 1234567sudo apt install gitsudo apt install cmakegit clone https://github.com/zrax/pycdc.gitcd pycdccmake .make #编译pycdc工具 Windows下的参考链接：https://blog.csdn.net/qq_63585949&#x2F;article&#x2F;details&#x2F;127080253 命令：**(需要把pycdc.exe和.pyc文件置于同一目录)** 1./pycdc.exe 文件名.pyc &gt; 文件名.py 方法二工具：uncompyle6 uncompyle6 现仅适用于 Python 2.4 到 3.8 版本 安装方法： 1pip install uncompyle6 命令：（选项和参数不可调换位置） 1uncompyle6 -o 文件名.py 文件名.pyc 方法三pyc文件反编译网站https://tool.lu/pyc/，适合接入互联网的情况 实战案例工具：pycdc 以第六届浙江省大学生网络与信息安全竞赛预赛的pyccc题为例 命令： 1./pycdc.exe baby.pyc 执行结果如图所示 此Python代码较为简单，不逐行解释，直接给出 write up 1234a = [102,109,99,100,127,52,114,88,97,122,85,125,105,127,119,80,120,112,98,39,109,52,55,106]for i in range(len(a)): print(chr(a[i] ^ i),end=&quot;&quot;) 此Python的write up代码较为简单，不逐行解释。仅在此备注，便于记忆： chr()函数是character的缩写 ord()函数是ordinal的缩写","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"Python","slug":"Python","permalink":"https://waltyoung.github.io/tags/Python/"}]},{"title":"CTF-Misc-swp","slug":"CTF-Misc-swp","date":"2023-11-04T03:57:57.000Z","updated":"2023-11-04T04:00:57.292Z","comments":true,"path":"2023/11/04/CTF-Misc-swp/","link":"","permalink":"https://waltyoung.github.io/2023/11/04/CTF-Misc-swp/","excerpt":"","text":"CTF-Misc-swp原题链接：https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]swp 解压压缩包，得到wget.pcapng pcapng文件PCAPNG全名Packet CAPture Next Generation，是一种现阶段广泛使用的网络数据包保存格式，其前身为PCAP。二者都可以用Wireshark打开。这里不对pcapng和pcap的具体文件格式展开详细了解、介绍。之后如果需要深入，会再作补充。 通过文件名，我们可以猜测这是关于wget的网络数据包文件。wget支持HTTP、HTTPS以及FTP协议。所以选择导出文件。具体操作如下图所示 在弹出的页面中可以观察到可疑文件secret.zip，选中并点击保存 解压得到的secret.zip，得到flag文件和.flag.swp文件。swp文件是Linux的交换文件。将.flag.swp文件拖入十六进制查看器中可见flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://waltyoung.github.io/tags/Wireshark/"}]},{"title":"PAT-Longest Symmetric String","slug":"PAT-Longest-Symmetric-String","date":"2023-11-01T08:13:24.000Z","updated":"2023-11-01T08:14:23.658Z","comments":true,"path":"2023/11/01/PAT-Longest-Symmetric-String/","link":"","permalink":"https://waltyoung.github.io/2023/11/01/PAT-Longest-Symmetric-String/","excerpt":"","text":"PAT-Longest Symmetric String原题链接:https://www.nowcoder.com/pat/5/problem/4027 Problem题目描述 Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given “Is PAT&amp;TAP symmetric?”, the longest symmetric sub-string is “s PAT&amp;TAP s”, hence you must output 11. 输入描述 Each input file contains one test case which gives a non-empty string of length no more than 1000. 输出描述 For each test case, simply print the maximum length in a line. 输入例子 Is PAT&amp;TAP symmetric? 输出例子 11 Answer题目难度 简单 解题算法 DP（动态规划） 我的代码（无注释版） 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int dp[1010][1010];int main()&#123; string s; getline(cin,s); int ans=1; for(int i=0;i&lt;s.length();i++) &#123; dp[i][i]=1; if(i &lt;= s.length()-1 &amp;&amp; s[i] == s[i+1]) &#123; dp[i][i+1]=1; ans=2; &#125; &#125; for(int L = 3; L &lt;= s.length(); L++) &#123; for (int i = 0; i + L - 1&lt; s.length(); i++) &#123; int j = i + L - 1; if(s[i] == s[j] &amp;&amp; dp[i+1][j-1] == 1) &#123; dp[i][j]=1; ans=L; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 部分代码解释 dp[1010][1010]数组是全局变量，会被默认初始化为全0，不需要使用memset函数初始化 使用getline(cin,s);以读入字符串，而不是cin &gt;&gt; s;，因为输入字符串中可能包含空格 第一个for语句初始化长度为1和2的子串 123456789for(int i=0;i&lt;s.length();i++)//初始化长度为1和2的子串&#123; dp[i][i]=1; if(i &lt;= s.length()-1 &amp;&amp; s[i] == s[i+1])//为了避免数组越界，`i &lt;= s.length()-1`必须先判断 &#123; dp[i][i+1]=1; ans=2; &#125;&#125; 第二个for语句 123456789101112for(int L = 3; L &lt;= s.length(); L++)//控制子串长度&#123; for(int i = 0; i + L - 1&lt; s.length(); i++) &#123; int j = i + L - 1; if(s[i] == s[j] &amp;&amp; dp[i+1][j-1] == 1) &#123; dp[i][j]=1; ans=L; &#125; &#125;&#125;","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"},{"name":"PAT","slug":"PAT","permalink":"https://waltyoung.github.io/tags/PAT/"},{"name":"DP","slug":"DP","permalink":"https://waltyoung.github.io/tags/DP/"}]},{"title":"PAT-Dating","slug":"PAT-Dating","date":"2023-10-31T12:16:01.000Z","updated":"2023-10-31T12:21:41.642Z","comments":true,"path":"2023/10/31/PAT-Dating/","link":"","permalink":"https://waltyoung.github.io/2023/10/31/PAT-Dating/","excerpt":"","text":"PAT-Dating原题链接:https://www.nowcoder.com/pat/5/problem/4028 Problem题目描述 Sherlock Holmes received a note with some strange strings: “Let’s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”. It took him only a minute to figure out that those strange strings are actually referring to the coded time “Thursday 14:04” – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter ‘D’, representing the 4th day in a week; the second common character is the 5th capital letter ‘E’, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is ‘s’ at the 4th position, representing the 4th minute. Now given two pairs of strings,you are supposed to help Sherlock decode the dating time. 输入描述 Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. 输出描述 For each test case, print the decoded time in one line, in the format “DAY HH:MM”, where “DAY” is a 3-character abbreviation for the days in a week – that is, “MON” for Monday, “TUE” for Tuesday, “WED” for Wednesday, “THU” for Thursday, “FRI” for Friday, “SAT” for Saturday, and “SUN” for Sunday. It is guaranteed that the result is unique for each case. 输入例子 3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 输出例子 THU 14:04 Answer题目难度 简单 解题算法 字符串查找 我的代码（无注释版） 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;string week[]=&#123;&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;,&quot;SUN&quot;&#125;;string day=&quot;0123456789ABCDEFGHIJKLMN&quot;;int main()&#123; string s1,s2,s3,s4; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4; for (int i = 0,j = 1; i &lt; min(s1.length(),s2.length()); i++) &#123; if( s1[i] == s2[i] &amp;&amp; isalnum( s1[i] ) ) &#123; switch (j) &#123; case 1: if( isalpha( s1[i] ) ) &#123; cout &lt;&lt; week[ s1[i] % &#x27;A&#x27; ]; j++; &#125; break; case 2: printf(&quot; %02u:&quot;,day.find( s1[i] ) ); j++; break; default: break; &#125; if(j == 3) break; &#125; &#125; for (int i = 0; i &lt; min(s3.length(),s4.length()); i++) &#123; if( s3[i] == s4[i] &amp;&amp; isalpha( s3[i] ) ) &#123; printf(&quot;%02d\\n&quot;,i); break; &#125; &#125; return 0;&#125; 此题较为简单，旨在复习字符串的函数。例如：.length()返回字符串长度；.find( &#39;A&#39; )返回一个无符号整型数表示A在字符串中的位置；在输出字符串中的单个字符时，使用%c，如printf(&quot;%c\\n&quot;,str[i]);，又如下 1cout &lt;&lt; week[ s1[i] % &#x27;A&#x27; ];//不能使用printf(&quot;%s&quot;,week[ s1[i] % &#x27;A&#x27; ]);","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"},{"name":"PAT","slug":"PAT","permalink":"https://waltyoung.github.io/tags/PAT/"}]},{"title":"PAT-Mooncake","slug":"PAT-Mooncake","date":"2023-10-28T09:51:37.000Z","updated":"2023-10-28T11:33:29.100Z","comments":true,"path":"2023/10/28/PAT-Mooncake/","link":"","permalink":"https://waltyoung.github.io/2023/10/28/PAT-Mooncake/","excerpt":"","text":"PAT-Mooncake原题链接:https://www.nowcoder.com/pat/5/problem/4031 Problem题目描述 Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings andcrusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts andthe prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed totell the maximum profit that can be made.Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds ofmooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousandtons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5&#x2F;2 &#x3D;9.45 (billion yuans). 输入描述 Each input file contains one test case. For each case, the first line contains 2 positive integers N (&lt;&#x3D;1000), the number of different kindsof mooncakes, and D (&lt;&#x3D;500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventoryamounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in aline are separated by a space. 输出描述 For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places. 输入例子 3 2018 15 1075 72 45 输出例子 94.50 Answer题目难度 简单 解题算法 贪心 我的代码（无注释版） 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Mooncake&#123; double amounts; double prices; double per; bool operator &lt; (const Mooncake &amp;next)const &#123; return per &gt; next.per; &#125;&#125;Mooncake,mooncake[1010];int main() &#123; int kind,demand; cin &gt;&gt; kind &gt;&gt; demand; Mooncake mooncake[1010]; for (int input = 0; input &lt; kind; input++) cin &gt;&gt; mooncake[input].amounts; for (int input = 0; input &lt; kind; input++) &#123; cin &gt;&gt; mooncake[input].prices; mooncake[input].per = mooncake[input].prices / mooncake[input].amounts; &#125; sort(mooncake,mooncake+kind); double sum=0; for (int input = 0; input &lt; kind; input++) &#123; if(demand &gt; mooncake[input].amounts) &#123; demand -= mooncake[input].amounts; sum += mooncake[input].prices; &#125; else &#123; sum += (demand / mooncake[input].amounts * mooncake[input].prices); break; &#125; &#125; printf(&quot;%.2f\\n&quot;,sum); return 0;&#125; 此题较为简单，旨在复习运算符重载与结构体数组排序 1234bool operator &lt; (const Mooncake &amp;next)const//运算符重载&#123; return per &gt; next.per;//自大到小降序排列&#125; 根据代码逻辑，如果当前对象的per值大于传入对象的per值，那么返回true，意味着当前对象应该排在传入对象之前，即按照per值从大到小排列。因此，这段代码是用于降序排列的。如果需要自小到大升序排列，则修改return per &gt; next.per;中的大于号&gt;为小于号&lt;","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"},{"name":"PAT","slug":"PAT","permalink":"https://waltyoung.github.io/tags/PAT/"}]},{"title":"VS Code SSH连接远程服务器","slug":"VS-Code-SSH连接远程服务器","date":"2023-10-14T07:39:22.000Z","updated":"2023-10-14T08:20:43.473Z","comments":true,"path":"2023/10/14/VS-Code-SSH连接远程服务器/","link":"","permalink":"https://waltyoung.github.io/2023/10/14/VS-Code-SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"VS Code SSH连接远程服务器因为 Vim 不支持代码补全，所以搭建一套 VS Code 的远端开发环境。笔者结合网络上的文章实操，遂有了此篇文章 环境：客户端：win10 服务器：Ubuntu 第0步：系统更新切换到root用户，并且注意全程使用root用户 1su 更新软件包列表 1apt-get update 进行一次升级 1apt-get upgrade 第1步：服务器安装SSH注意使用root用户 12apt-get install net-toolsapt-get install openssh-server 第2步：服务器配置SSH打开 SSH 配置文件 1vim /etc/ssh/sshd_config 修改SSH配置项： 取消PermitRootLogin的注释 取消PubkeyAuthentication的注释 添加RSAAuthentication yes内容 如下图所示 第3步：客户端安装SSH通过安装 Git 来获取 SSH 功能。因为我的客户端是Win10，没有默认搭载 Git。如果读者是相同的环境，可以查看https://blog.csdn.net/mukes/article/details/115693833。该文章详细介绍了 Git 的安装教程 安装完成后使用ssh检查安装是否成功 若如上图所示，则代表 SSH 已经安装成功 第4步：客户端生成密钥对使用如下命令，生成 SSH 密钥对 1ssh-keygen 第5步：服务器保存客户端的 SSH 公钥在上一步中生成的密钥对，默认保存路径为：C:\\Users\\user\\.ssh（路径中的user需要读者自行替换为实际的用户名） 将.ssh文件夹下的id_rsa.pub，复制到远程服务器的.ssh文件夹中。（id_rsa.pub是公钥，从其后缀名.pub也可见。pub是 public 的前3个字母） .ssh文件夹可以是根目录下的.ssh文件夹，也可以是用户目录下的.ssh文件夹。如果没有.ssh文件夹，则新建一个文件夹，命名为.ssh即可。 在.ssh目录下，使用如下命令，生成authorized_keys文件，可以在连接到此服务器时不输入密码 1cat id_rsa.pub &gt;&gt; authorized_keys 第6步：客户端VS Code添加插件并配置在 VS Code 中添加Remote - SSH插件 若添加成功，则在左侧可见 远程资源管理器。点击远程资源管理器，再点击小齿轮，如下图所示 选择第一项，如下图所示 根据实际情况，修改配置项 1234Host 服务器主机名 HostName 服务器IP地址 User 用户名 IdentityFile &quot;私钥路径&quot; 完成","categories":[],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"https://waltyoung.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"}]},{"title":"CTF-Crypto-Caesar","slug":"CTF-Crypto-Caesar","date":"2023-10-08T10:59:56.000Z","updated":"2023-10-08T11:01:39.518Z","comments":true,"path":"2023/10/08/CTF-Crypto-Caesar/","link":"","permalink":"https://waltyoung.github.io/2023/10/08/CTF-Crypto-Caesar/","excerpt":"","text":"CTF-Crypto-Caesar笔者遇到凯撒加密的某一环节，因凯撒加密的方式较为简单，决定手写解密代码，在此存储、记录 近期在学习计算机网络编程（socket 编程），对C语言更加熟练一些，遂用C语言写了解密代码 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; char caesar[110]; scanf(&quot;%s&quot;,caesar); for(int i=0;i&lt;26;i++) &#123; printf(&quot;%d &quot;,26-i); for(int j=0;caesar[j]!=&#x27;\\0&#x27;;j++)//(char)将ASCII码转化为字符 &#123; if(caesar[j] &gt;= &#x27;A&#x27; &amp;&amp; caesar[j] &lt;= &#x27;Z&#x27;) printf(&quot;%c&quot;,(char)( (caesar[j]-&#x27;A&#x27;)+i )%26 + &#x27;A&#x27; ); if(caesar[j] &gt;= &#x27;a&#x27; &amp;&amp; caesar[j] &lt;= &#x27;z&#x27;) printf(&quot;%c&quot;,(char)( (caesar[j]-&#x27;a&#x27;)+i )%26 + &#x27;a&#x27; ); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 此C语言代码较为简单，不逐行解释","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"Crypto","slug":"Crypto","permalink":"https://waltyoung.github.io/tags/Crypto/"},{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"}]},{"title":"CTF-Reverse-Sign Up","slug":"CTF-Reverse-Sign-Up","date":"2023-09-28T09:55:57.000Z","updated":"2023-09-28T09:57:25.316Z","comments":true,"path":"2023/09/28/CTF-Reverse-Sign-Up/","link":"","permalink":"https://waltyoung.github.io/2023/09/28/CTF-Reverse-Sign-Up/","excerpt":"","text":"CTF-Reverse-Sign Up原题链接：https://www.polarctf.com/#/page/challenges的Sign Up 笔者拿到该题，优先置于 exeinfope 中侦壳 如上图所示，64位，无壳 置于 IDA 中反编译 如上图所示，这是 main 函数的汇编代码 按下F5（笔记本为Fn + F5）展示C语言的代码，如下图所示 _main();无实义 Input_Data();从命名上看用于输入 Check_Data();从命名上看用于检查输入，判断 flag 是否正确 Input_Data()函数如下 从 main 函数、Input_Data 函数可以发现Buffer、num、password是全局变量（因为在 main 函数、Input_Data 函数都没有定义任何变量） 双击Buffer跳转到全局变量Buffer定义的十六进制处，如下图所示 按下A（大小写无关）将十六进制解码成字符，如下图所示 如果没有成功，且报错，请参考这篇文章：https://blog.csdn.net/qq_36535153&#x2F;article&#x2F;details&#x2F;111252053 按下Esc返回Input_Data()函数，如下图所示 可见&amp;Buffer替换为中文字符，共需要2个输入num、password Check_Data()函数如下 解码后的Check_Data()函数如下 如上图所示，在2个for循环中分别使用到了key_num、key_password数组 双击key_num跳转到全局变量key_num定义的十六进制处，如下图所示 key_num数组的值是192168109 key_password数组的值是root 通过后3个 if 语句可以得知只有在标志位v3为1时表示”密码正确!”，v4为1时表示”账号正确” 1234567if ( !v4 &amp;&amp; !v3 ) return puts(&quot;账号密码错误:&quot;);if ( !v4 ) return puts(&quot;账号错误:&quot;);if ( v3 ) return printf(&quot;密码正确!&quot;);return puts(&quot;密码错误:&quot;); 第一个 for 语句表明num数组的值的AscII值是key_num数组的值的AscII值减一。需要注意的是循环只能执行7次，但key_num数组长度为9（笔者第一次尝试解题时就被） 12345for ( i = 0; i &lt;= 6; ++i )&#123; if ( num[i] + 1 != key_num[i] ) v4 = 0;&#125; 第二个 for 语句表明password数组的值的AscII值是key_password数组的值的AscII值减二。循环可以执行4次，与key_password数组的长度一致 12345for ( j = 0; j &lt;= 3; ++j )&#123; if ( password[j] + 2 != key_password[j] ) v3 = 0;&#125; 根据以上分析，我们需要将192168109的前7位减一，root的4位向前推2位 得到081057008和pmmr 验证Sign Up.exe的答案 后记 在做逆向题时，遇到的0i64，1i64，1000i64相当于将0，1，1000转换为64位格式进行处理，i64跟u、f等类似，如1.0f，2000.0f。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Windows","slug":"Windows","permalink":"https://waltyoung.github.io/tags/Windows/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"PE","slug":"PE","permalink":"https://waltyoung.github.io/tags/PE/"}]},{"title":"CTF-Reverse-AndroidXor","slug":"CTF-Reverse-AndroidXor","date":"2023-09-26T10:15:48.000Z","updated":"2023-09-26T10:16:38.381Z","comments":true,"path":"2023/09/26/CTF-Reverse-AndroidXor/","link":"","permalink":"https://waltyoung.github.io/2023/09/26/CTF-Reverse-AndroidXor/","excerpt":"","text":"CTF-Reverse-AndroidXor原题链接：https://www.polarctf.com/#/page/challenges的AndroidXor 三个工具（即工作流）： Apktool：通过该工具能完整的从 apk 中提取出 resource、dex、manifest、xml 等文件，也可以修改资源文件之后 rebuild 生成一个 apk 文件 dex2jar：通过该工具将 dex 文件生成（包含class 文件的）jar 文件 JD-GUI：通过该工具，可以通过可视化的界面操作查看 jar 文件，即查看反编译后的源码情况 笔者拿到该题，发现是 apk 文件，将其重命名为 zip 文件后打开。（apk 文件是一个 zip 压缩包，如果仅仅是想获取源码文件，不关心具体资源文件，可以直接解压提取 dex 文件，再进行 dex 到 jar 文件的转换。） 下图可见压缩包内的 dex 文件 解压classes.dex文件，置于dex2jar-v2.3\\target目录下 使用命令将 dex 文件生成 jar 文件 1.\\d2j-dex2jar.bat target\\classes.dex 由下图可见生成了 classes-dex2jar.jar 文件 将 jar 文件置于 jd-gui.exe 反编译，定位目标文件，由下图可见是MainActivity.java文件 将源文件反编译、保存 置于IDEA查看源文件，在MainActivity.java文件可以注意到 Xor 函数，根据题目的名字（Android异或）和提示，我们可以确定 Xor 函数是核心代码 如下是 Xor 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public String Xor(String paramString1, String paramString2) &#123; String str1; char[] arrayOfChar = new char[paramString1.length()]; int i = paramString1.length(); String str2 = &quot;wrong!!!&quot;; if (i != 25) &#123; str1 = &quot;wrong!!!&quot;; &#125; else &#123; str1 = &quot;you win!!!&quot;; &#125; i = 0; while (true) &#123; if (i &lt; paramString1.length()) &#123; char c = (char)(paramString1.charAt(i) ^ paramString2.charAt(i % paramString2.length())); arrayOfChar[i] = c; (new char[25])[0] = &#x27;\\016&#x27;; (new char[25])[1] = &#x27;\\r&#x27;; (new char[25])[2] = &#x27;\\021&#x27;; (new char[25])[3] = &#x27;\\027&#x27;; (new char[25])[4] = &#x27;\\002&#x27;; (new char[25])[5] = &#x27;K&#x27;; (new char[25])[6] = &#x27;I&#x27;; (new char[25])[7] = &#x27;7&#x27;; (new char[25])[8] = &#x27; &#x27;; (new char[25])[9] = &#x27;\\036&#x27;; (new char[25])[10] = &#x27;\\024&#x27;; (new char[25])[11] = &#x27;I&#x27;; (new char[25])[12] = &#x27;\\n&#x27;; (new char[25])[13] = &#x27;\\002&#x27;; (new char[25])[14] = &#x27;\\f&#x27;; (new char[25])[15] = &#x27;&gt;&#x27;; (new char[25])[16] = &#x27;(&#x27;; (new char[25])[17] = &#x27;@&#x27;; (new char[25])[18] = &#x27;\\013&#x27;; (new char[25])[19] = &#x27;\\&#x27;&#x27;; (new char[25])[20] = &#x27;K&#x27;; (new char[25])[21] = &#x27;Y&#x27;; (new char[25])[22] = &#x27;\\031&#x27;; (new char[25])[23] = &#x27;A&#x27;; (new char[25])[24] = &#x27;\\r&#x27;; if ((new char[25])[i] != c) &#123; paramString1 = str2; break; &#125; i++; continue; &#125; paramString1 = str1; break; &#125; return paramString1;&#125; 按住 ctrl键，跳转至最近一次的方法调用 可以注意到 Onclick 方法相当于C语言的main函数，调用 Xor 方法，传入 变量str、字符串happyx3。 Xor 方法内的变量paramString1的初始值来自变量 str ，变量 str 来自输入。变量paramString2的初始值是happyx3 笔者将逐段解释 Xor 方法 123456789String str1;char[] arrayOfChar = new char[paramString1.length()];int i = paramString1.length();String str2 = &quot;wrong!!!&quot;;if (i != 25) &#123; str1 = &quot;wrong!!!&quot;;&#125; else &#123; str1 = &quot;you win!!!&quot;;&#125; 本段代码第二行定义变量arrayOfChar字符数组；第三行定义变量i的值是字符串变量paramString1的长度，并且根据 if-else 语句的内容看，只有字符串的长度等于25时，才是正确的 12345678910111213141516171819202122232425262728293031323334353637383940i = 0;while (true) &#123; if (i &lt; paramString1.length()) &#123; char c = (char)(paramString1.charAt(i) ^ paramString2.charAt(i % paramString2.length())); arrayOfChar[i] = c; (new char[25])[0] = &#x27;\\016&#x27;; (new char[25])[1] = &#x27;\\r&#x27;; (new char[25])[2] = &#x27;\\021&#x27;; (new char[25])[3] = &#x27;\\027&#x27;; (new char[25])[4] = &#x27;\\002&#x27;; (new char[25])[5] = &#x27;K&#x27;; (new char[25])[6] = &#x27;I&#x27;; (new char[25])[7] = &#x27;7&#x27;; (new char[25])[8] = &#x27; &#x27;; (new char[25])[9] = &#x27;\\036&#x27;; (new char[25])[10] = &#x27;\\024&#x27;; (new char[25])[11] = &#x27;I&#x27;; (new char[25])[12] = &#x27;\\n&#x27;; (new char[25])[13] = &#x27;\\002&#x27;; (new char[25])[14] = &#x27;\\f&#x27;; (new char[25])[15] = &#x27;&gt;&#x27;; (new char[25])[16] = &#x27;(&#x27;; (new char[25])[17] = &#x27;@&#x27;; (new char[25])[18] = &#x27;\\013&#x27;; (new char[25])[19] = &#x27;\\&#x27;&#x27;; (new char[25])[20] = &#x27;K&#x27;; (new char[25])[21] = &#x27;Y&#x27;; (new char[25])[22] = &#x27;\\031&#x27;; (new char[25])[23] = &#x27;A&#x27;; (new char[25])[24] = &#x27;\\r&#x27;; if ((new char[25])[i] != c) &#123; paramString1 = str2; break; &#125; i++; continue; &#125; paramString1 = str1; break;&#125; 优先解释关键代码char c = (char)(paramString1.charAt(i) ^ paramString2.charAt(i % paramString2.length()));的作用是将两个字符串中对应位置的字符进行异或运算，并将结果赋值给变量c。 具体解释如下： paramString1.charAt(i)：表示取出字符串paramString1中索引为i的字符。 paramString2.charAt(i % paramString2.length())：表示取出字符串paramString2中索引为i % paramString2.length()的字符。这里使用了取余运算符%来保证索引不超过字符串长度。 ^：表示异或运算符，将两个字符进行异或运算。 (char)：将异或运算的结果强制转换为字符类型。 (new char[25])[0] = &#39;\\016&#39;;创建了一个长度为 25 的字符数组，并将数组的第一个元素赋值为十进制数 14 对应的字符。其他类似语句同理。需要注意的是 \\016 表示八进制数 16，计算机语言中八进制数用数字0开头，例如：010、011、016都是八进制数 1234if ((new char[25])[i] != c) &#123; paramString1 = str2; break;&#125; 该语句确定了条件判断依据，即输入的字符串与happyx3字符串异或的结果必须等于(new char[25])[i]的值 如下是笔者写的解题脚本，可以直接得到 flag 。如觉得输出结果不方便，可以自行定义一个 list ，将输出结果保存到该 list ，使用&#39;&#39;.join()方法 123456ch = [ &#x27;\\016&#x27;,&#x27;\\r&#x27;,&#x27;\\021&#x27;,&#x27;\\027&#x27;,&#x27;\\002&#x27;,&#x27;K&#x27;,&#x27;I&#x27;,&#x27;7&#x27;,&#x27; &#x27;,&#x27;\\036&#x27;,&#x27;\\024&#x27;,&#x27;I&#x27;,&#x27;\\n&#x27;,&#x27;\\002&#x27;,&#x27;\\f&#x27;,&#x27;&gt;&#x27;,&#x27;(&#x27;,&#x27;@&#x27;,&#x27;\\013&#x27;,&#x27;\\&#x27;&#x27;,&#x27;K&#x27;,&#x27;Y&#x27;,&#x27;\\031&#x27;,&#x27;A&#x27;,&#x27;\\r&#x27;]string = [&#x27;h&#x27;, &#x27;a&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;x&#x27;, &#x27;3&#x27;]for i, c in enumerate(ch): print( chr( ord(c) ^ ord( string[i % len(string)] ) ) ) 笔者将逐行解释代码 1234ch = [ &#x27;\\016&#x27;,&#x27;\\r&#x27;,&#x27;\\021&#x27;,&#x27;\\027&#x27;,&#x27;\\002&#x27;,&#x27;K&#x27;,&#x27;I&#x27;,&#x27;7&#x27;,&#x27; &#x27;,&#x27;\\036&#x27;,&#x27;\\024&#x27;,&#x27;I&#x27;,&#x27;\\n&#x27;,&#x27;\\002&#x27;,&#x27;\\f&#x27;,&#x27;&gt;&#x27;,&#x27;(&#x27;,&#x27;@&#x27;,&#x27;\\013&#x27;,&#x27;\\&#x27;&#x27;,&#x27;K&#x27;,&#x27;Y&#x27;,&#x27;\\031&#x27;,&#x27;A&#x27;,&#x27;\\r&#x27;]string = [&#x27;h&#x27;, &#x27;a&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;x&#x27;, &#x27;3&#x27;] 创建2个 list (相当于C语言的数组，但其中的元素可以是不同的数据类型) 12for i, c in enumerate(ch): print( chr( ord(c) ^ ord( string[i % len(string)] ) ) ) 使用 enumerate 函数来同时迭代ch列表和索引值，避免使用range和索引访问。 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 普通的 for 循环 12345i = 0seq = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for element in seq: print(i, seq[i]) i += 1 使用 enumerate 的 for 循环 123seq = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]for i, element in enumerate(seq): print(i, element) i % len(string)取出字符串中的字符，模仿自 Java 源代码i % paramString2.length() 使用 ord() 将字符转换为对应的ASCII码值进行异或运算。 使用 chr() 将ASCII码值转换为对应的字符。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"Java","slug":"Java","permalink":"https://waltyoung.github.io/tags/Java/"},{"name":"Python","slug":"Python","permalink":"https://waltyoung.github.io/tags/Python/"}]},{"title":"CTF-Reverse-Java_Tools","slug":"CTF-Reverse-Java-Tools","date":"2023-09-25T02:04:48.000Z","updated":"2023-09-25T02:10:51.242Z","comments":true,"path":"2023/09/25/CTF-Reverse-Java-Tools/","link":"","permalink":"https://waltyoung.github.io/2023/09/25/CTF-Reverse-Java-Tools/","excerpt":"","text":"CTF-Reverse-Java_Tools原题链接：https://www.polarctf.com/#/page/challenges的Java_Tools 笔者拿到该题，发现是 jar 文件，优先置于 jd-gui.exe 反编译。可见如下两个文件 Test.java 文件的内容： 12345678910111213141516package main.java;import java.util.Scanner;public class Test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println(&quot;Welcome to Polar_Ctf!,come to play!&quot;); System.out.println(&quot;Please Input : &quot;); String name = in.next(); char[] Strings = name.toCharArray(); Tools.Add_1(Strings, 3); Tools.Re(Strings); Tools.Judge(Strings); &#125;&#125; Tools.java 文件的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package main.java;import java.util.ArrayList;public class Tools &#123; public static int j = 6; public static void Re(char[] str) &#123; for (int i = 0; i &lt; str.length / 2 - 1; i++) &#123; char temp = str[i]; str[i] = str[str.length - i - 1]; str[str.length - i - 1] = temp; &#125; &#125; public static void Xor(char[] str) &#123; for (int i = 0; i &lt; str.length; i++) str[i] = (char)(str[i] ^ j); &#125; public static void Add_1(char[] str, int x) &#123; for (int i = 0; i &lt; str.length; i++) str[i] = (char)(str[i] + x); &#125; public static void Judge(char[] str) &#123; ArrayList&lt;Character&gt; Result = new ArrayList&lt;&gt;(); ArrayList&lt;Character&gt; Flag = new ArrayList&lt;&gt;(); char[] arrayOfChar1; int i; byte b; for (arrayOfChar1 = str, i = arrayOfChar1.length, b = 0; b &lt; i; ) &#123; Character character = Character.valueOf(arrayOfChar1[b]); Result.add(Character.valueOf(character.charValue())); b++; &#125; String name = &quot;$gourZroohK&quot;; String sttr = new String(str); if (name.contains(sttr)) &#123; System.out.println(&quot;You Are Right!MD5!&quot;); &#125; else &#123; System.out.println(&quot;You Are Wrong! please try it again!&quot;); &#125; char[] Strings = name.toCharArray(); for (char c : Strings) Flag.add(Character.valueOf(c)); if (Result.equals(Flag)) &#123; System.out.println(&quot;You Are Right!MD5!&quot;); &#125; else &#123; System.out.println(&quot;You Are Wrong! please try it again!&quot;); &#125; &#125;&#125; 显然可见 Test.java 调用 Tools.java 的方法，直接阅读代码可知 Add_1 方法是默认情况的凯撒加密， Re 方法是互换位置， Judge 方法是判断输入是否正确， Xor 方法没有使用 实战或比赛中，可以对代码稍加分析后立即调试，在调试中观察代码的执行情况 为了便于调试，我们可以将源文件置于 IDEA 项目的 src 目录下，并且重命名 Test.java 为 Main.java，删除每个java文件的第一行package main.java 如图所示java文件位置 以12345678为输入，作示例 下图是步入 Add_1 函数前，Strings数组的内容就是笔者的输入 下图是步出 Add_1 函数后即步入 Re 函数前，Strings数组的内容是笔者的输入经过偏移值为3的凯撒加密后的结果 下图是步出 Re 函数后即步入 Judge 函数前，Strings数组的内容是步入Re函数前的数组 头尾互换。（具体细节情读者自行查看，笔者表述能力不太好QAQ） 笔者接下来将图文结合逐行解释代码 12ArrayList&lt;Character&gt; Result = new ArrayList&lt;&gt;();ArrayList&lt;Character&gt; Flag = new ArrayList&lt;&gt;(); 如上代码的作用是新建 Result 、 Flag 数组 12345for (arrayOfChar1 = str, i = arrayOfChar1.length, b = 0; b &lt; i; ) &#123; Character character = Character.valueOf(arrayOfChar1[b]); Result.add(Character.valueOf(character.charValue())); b++;&#125; 如上代码的作用是复制步入 Judge 函数前 Strings数组的内容到 Result 数组 调试时也可验证如上代码的作用，下图是Result数组的内容， Result 数组的内容和 str 数组、步入 Judge 函数前 Strings数组的内容完全相同 12String name = &quot;$gourZroohK&quot;;String sttr = new String(str); 如上代码的作用是第一行，创建一个 String 类型的变量 name，并赋值$gourZroohK；第二行，将传入的数组 str 转化为 String 类型的字符串，并保存到 String 类型的变量sttr 中 12345if (name.contains(sttr)) &#123; System.out.println(&quot;You Are Right!MD5!&quot;);&#125; else &#123; System.out.println(&quot;You Are Wrong! please try it again!&quot;);&#125; 如上代码的作用是判断 sttr 是否包含在 name 中。关键方法是contains()。*(与下一段代码相比，不是很重要)* 123char[] Strings = name.toCharArray();for (char c : Strings) Flag.add(Character.valueOf(c)); 如上代码的作用是第一行，将 name 字符串转化为 char 类型的数组，并保存到 char 类型的 Strings 数组中；第二行，for 语句的作用的本质是复制第一行的 Strings数组的内容到 Flag 数组中 调试时也可验证如上代码的作用，下图是 Flag 数组的内容， Flag 数组的内容和 Strings数组的内容完全相同 12345if (Result.equals(Flag)) &#123; System.out.println(&quot;You Are Right!MD5!&quot;);&#125; else &#123; System.out.println(&quot;You Are Wrong! please try it again!&quot;);&#125; 如上代码的作用是判断 Result 数组是否与 Flag 数组相同。关键方法是equals()。*(与上一段 if 语句相比，这句更重要。因为上一段 if 语句要求 包含flag，这一段 if 语句要求 等于flag)* 总结 此段代码的正向操作是先偏移值为3的凯撒加密，再进行移位 故反向操作应该是先进行移位，再偏移值为3的凯撒加密 具体步骤如下： 将String name = &quot;$gourZroohK&quot;;的name变量的值，即$gourZroohK，进行移位，可得KhourZroog$ 对KhourZroog$进行偏移值为3的凯撒解密，可得HelloWorld! 将HelloWorld!进行 MD5 计算后可得flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"Java","slug":"Java","permalink":"https://waltyoung.github.io/tags/Java/"}]},{"title":"CTF-Misc-大白","slug":"CTF-Misc-大白","date":"2023-09-23T16:38:14.000Z","updated":"2023-09-23T16:39:26.804Z","comments":true,"path":"2023/09/24/CTF-Misc-大白/","link":"","permalink":"https://waltyoung.github.io/2023/09/24/CTF-Misc-%E5%A4%A7%E7%99%BD/","excerpt":"","text":"CTF-Misc-大白原题链接：https://buuoj.cn/challenges#%E5%A4%A7%E7%99%BD 笔者拿到该题，仍是先使用 binwalk 提取 1binwalk -e dabai.png --run-as=root 得到如下文件 由图可知，文件 5B 的大小是 0B，为空文件；文件 5B.zlib 的大小是 146.9KB，大于1KB，不为空文件 尝试使用 python 的 zlib 包解压时报错zlib.error: Error -3 while decompressing data: incorrect data check，使用十六进制编辑器打开 5B.zlib 文件，可见 5B.zlib 文件的文件头（魔术头）为78 5E 查询网络可知 zlib 文件的文件头根据加密方式的不同分为如下3种： 笔者无法解压该 5B.zlib 文件 随后许久，笔者才注意到原图不能被“爱奇艺万能看图王”打开，能被 win10 的“照片”，在 Linux 中打开原图 大白.png 可见具体报错————IHDR：CRC error 查询网络可知 PNG 文件结构如下： 查询网络可知 PNG 数据块结构如下： png 图片可以使用 TweakPng 快速检查文件 使用 TweakPng 打开被修改尺寸或者是其他信息的PNG图片时，会有提示。 如上图所示，提示CRC错误。 存在两种可能： 图片CRC被修改：尝试用十六进制编辑器修改CRC 图片尺寸被修改：尝试用十六进制编辑器修改图片尺寸 笔者首先尝试了第一种可能，即修改CRC，没有得到flag 笔者其后准备计算图片的正确尺寸，下面附上爆破 png 图片正确尺寸的代码 123456789101112import binasciiimport structcrcbp = open(&quot;xxx.png&quot;, &quot;rb&quot;).read() #打开图片for i in range(1024): for j in range(1024): data = crcbp[12:16] + \\ struct.pack(&#x27;&gt;i&#x27;, i)+struct.pack(&#x27;&gt;i&#x27;, j)+crcbp[24:29] crc32 = binascii.crc32(data) &amp; 0xffffffff if crc32 == 0xffffffff: #图片当前CRC print(i, j) print(&#x27;hex:&#x27;, hex(i), hex(j)) 以下是本题实际使用的代码，需要注意的是在Python中，在字符串前面加上r的原因是为了处理文件路径中的反斜杠。通常在Windows系统中，文件路径的反斜杠会被解释为转义字符，这可能导致路径错误或无法识别。为了避免这个问题，可以使用双反斜杠或者使用原始字符串（在字符串前面加上r）来表示路径。原始字符串会保留字符串中的所有字符，不进行转义，从而确保文件路径的准确性。 爆破结果如下 这里可以选择不求甚解地直接在十六进制编辑器里搜索02 A7，然后将其后的数据修改为01 df。笔者选择记录 PNG 文件头格式以便日后的学习 第一个红框内的89 50 4E 47 0D 0A 1A 0A是 PNG 头部 署名域 第二个红框内的00 00 00 0D是 Length，即 IHDR 数据域的长度（具体原因可见本文第七张图） 第三个红框内的49 48 44 52是 Chunk Type Code，即数据域类型是IHDR 其后就是 Chunk Data 第四个红框内的00 00 02 A7是 Width 第五个红框内的00 00 01 00是 Height 参考链接：https://blog.csdn.net/u013943420/article/details/76855416 结论： PNG 文件第17个字节至第24个字节是 PNG 的宽和高 修改后点击另存为，再次打开可见flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-九连环","slug":"CTF-Misc-九连环","date":"2023-09-22T23:02:44.000Z","updated":"2023-09-22T14:04:34.183Z","comments":true,"path":"2023/09/23/CTF-Misc-九连环/","link":"","permalink":"https://waltyoung.github.io/2023/09/23/CTF-Misc-%E4%B9%9D%E8%BF%9E%E7%8E%AF/","excerpt":"","text":"CTF-Misc-九连环原题链接：https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF 笔者拿到该题，先使用 Stegsolve ，没有发现信息；再使用十六进制编辑器，可以发现 zip 文件头（50 4B 03 04和PK），证明其隐写了 zip 文件。 使用 binwalk 提取 1binwalk -e 123456cry.jpg --run-as=root 提取得到一个 zip 压缩包，使用压缩软件打开可见2个文件，且good-已合并.jpg从文件名上判断必然包含隐藏信息 直接解压会报错 根据提示，笔者原以为需要修复 jpg 文件，但是想到压缩的本质是找出文件中字符串的概率分布，然后将出现概率高的字符串替换成更短的形式，所以想到应该是 zip 伪加密 目前为止，解题思路为最终的 flag 在 qwe.zip 压缩包内，并且 qwe.zip 压缩包是真加密，密码隐藏在 good-已合并.jpg 内，但good-已合并.jpg被伪加密了（判断依据：只有 qwe.zip 压缩包是真加密，其他位置的全局方式位标志都应为不加密） 如上图所示，大红框指向的 qwe.zip 压缩包是真加密，good-已合并.jpg是伪加密 笔者这里直接给出具体的操作方法，关于 zip 伪加密可以参考我的个人博客的这篇文章https://waltyoung.github.io/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/ 结合本文第四张图和第五张图，将红框处的01修改为00后另存为 关于 CTF压缩包 的分析，请参考这篇文章https://blog.csdn.net/qq_42551635&#x2F;article&#x2F;details&#x2F;116792548 再次解压后可得到图片good-已合并.jpg，使用 Stegsolve ，没有发现信息 笔者查阅网络后得知本题使用了 Steghide Steghide 下载地址：https://steghide.sourceforge.net/index.php 使用方法是一般Windows环境变量的配置 Steghide的命令如下： 查看图片中嵌入的文件信息 1steghide info 图片名.jpg 隐藏文件 1steghide embed -cf (需要将密码放入的文件) -ef (需要加密的文件) 提取隐藏的文件 1steghide extract -sf 图片名 （-p 密码） 使用命令steghide extract -sf good-已合并.jpg提取文件，需要注意的是本题没有在此设定密码，但不保证之后的题目同样不设密码 由上图可见，隐藏文件保存到了 ko.txt，打开后得到真加密压缩包的密码，解压即可得到flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"Vim优化指南","slug":"Vim优化指南","date":"2023-09-21T16:29:18.000Z","updated":"2023-09-22T01:42:42.453Z","comments":true,"path":"2023/09/22/Vim优化指南/","link":"","permalink":"https://waltyoung.github.io/2023/09/22/Vim%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/","excerpt":"","text":"Vim优化指南Vim 作为 Linux 中常用编辑器，使用者可根据自己的需要配置 Vim 的工作环境。 配置方法如下： 在末行模式下使用命令:set 配置项或set 配置项 = 值或配置项进行配置。该配置方法的特点是 Vim 重启后丢失原有的末行模式下的配置 修改 Vim 配置文件/etc/vim/vimrc的内容。需要注意的是双引号是注释符。该配置方法的特点是对所有用户生效 修改 用户home 目录下的配置文件~/.vimrc的内容。~是指 用户home 目录。该配置方法的特点是仅对当前用户生效 在正式开始之前，请先备份 .vimrc 或 vimrc 文件。命令：cp vimrc vimrc.bak 123456789101112131415161718192021222324252627282930313233set nocompatiblesyntax enablesyntax onfiletype indent onset tabstop=4set shiftwidth=4set autoindentset cindentset backspace=2set cindent shiftwidth=4set smartindentset numberset showmatchset matchtime=5set background=darkset mouse=aset rulerset hlsearchset incsearchset nowrapscanset cursorlineset history=1000set ignorecaseinoremap( ()&lt;LEFT&gt;inoremap[ []&lt;LEFT&gt;inoremap&#123; &#123;&lt;CR&gt;&#125;&lt;UP&gt;inoremap&lt; &lt;&gt;&lt;LEFT&gt;inoremap&quot; &quot;&quot;&lt;LEFT&gt;inoremap&#x27; &#x27;&#x27;&lt;LEFT&gt;set wrapset laststatus=2set cmdheight=1set shm+=I 以下是对Vim配置项的解释： set nocompatible: 禁用vi兼容模式，启用vim自身的特性。 syntax enable: 启用语法高亮。 syntax on: 启用语法高亮。 filetype indent on: 根据文件类型启用自动缩进。 set tabstop=4: 设置制表符的宽度为4个空格。 set shiftwidth=4: 设置每次缩进或反缩进的宽度为4个空格。 set autoindent: 启用自动缩进。 set cindent: 启用C语言风格的自动缩进。 set backspace=2: 允许在插入模式下删除任何字符，包括换行符和缩进。 set smartindent: 启用智能缩进，根据上一行的缩进进行自动缩进。 set number: 显示行号。 set showmatch: 在输入括号时，高亮显示匹配的括号。 set matchtime=5: 设置括号匹配高亮的时间（单位为十分之一秒）。 set background=dark: 设置背景为暗色，适用于黑色背景的终端。 set mouse=a: 启用鼠标支持。 set ruler: 显示光标位置的行号和列号。 set hlsearch: 高亮显示搜索结果。 set incsearch: 在输入搜索模式时，实时显示匹配的结果。 set nowrapscan: 禁止搜索到文件末尾后自动回到开头。 set cursorline: 高亮显示当前行。 set history=1000: 设置命令历史记录的最大数量为1000。 set ignorecase: 在搜索时忽略大小写。 inoremap( ()&lt;LEFT&gt;: 在插入模式下，将输入的”(“转换为”()”并将光标移动到左括号内。 inoremap[ []&lt;LEFT&gt;: 在插入模式下，将输入的”[“转换为”[]”并将光标移动到左括号内。 inoremap&#123; &#123;&lt;CR&gt;&#125;&lt;UP&gt;: 在插入模式下，将输入的”{“转换为”{}”并将光标移动到上一行。 inoremap&lt; &lt;&gt;&lt;LEFT&gt;: 在插入模式下，将输入的”&lt;”转换为”&lt;&gt;”并将光标移动到左括号内。 inoremap&quot; &quot;&quot;&lt;LEFT&gt;: 在插入模式下，将输入的引号转换为一对引号并将光标移动到引号内。 inoremap&#39; &#39;&#39;&lt;LEFT&gt;: 在插入模式下，将输入的单引号转换为一对单引号并将光标移动到单引号内。 set wrap: 自动换行显示长行。 set laststatus=2: 在状态栏始终显示状态行。 set cmdheight=1: 设置命令行的高度为1行。 set shm+=I: 将当前行的行号显示在状态栏上。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://waltyoung.github.io/tags/Vim/"}]},{"title":"Base64隐写","slug":"Base64隐写","date":"2023-09-21T14:36:31.000Z","updated":"2023-09-21T16:40:09.146Z","comments":true,"path":"2023/09/21/Base64隐写/","link":"","permalink":"https://waltyoung.github.io/2023/09/21/Base64%E9%9A%90%E5%86%99/","excerpt":"","text":"Base64隐写原题链接：https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99 Base64 很常见，在 ctf 比赛中更是常见。笔者在遇到本题之前，只将其当做一种加密方式，现在对其做更深入的理解。 Base64 介绍在计算机中的字节共有256个组合，对应就是ascii码，而ascii码的128～255之间的值是不可见字符。而在网络上交换数据时，由于不同的设备对字符的处理方式有区别，不可见字符有可能被错误处理，所以就在传输之前将数据进行Base64编码，以可见字符进行传输。 Base64 是一种基于 64 个可打印字符（ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，特殊的 = 作为补零时的后缀）来表示二进制数据的表示方法。因为 2 ^ 6 &#x3D; 64，所以每 6 个 bit 为一个单元，对应某个可打印字符。3 个字节有 24 个 bit ，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。 下图是 64 个字符的对应表 Base64 转换以 Man 作为例子，将字符的 ASCII 码换成二进制，从高位取 6 个 bit ，再转化成十进制， 结合表格，就能够得出对应的字符。 如果编码的字节数不能被 3 整除的话，如下图所示，后面就会多出一个或两个字节，这种情况下就用 0 填充缺省的字节，使其能够被 3 整除，再像上面一样进行 Base64 转换，并在编码后的 Base64 文本后加上一个或两个 = ，代表填补的字节数。 Base64 在 URL 中的使用由于标准 Base64 编码过后的数据会出现 / 和 + ，在 URL 中是由特殊含义的，浏览器会将他们变为形如 %xx 的格式，这些 % 存入数据库时还要进行转换，因此 URL 改进的 Base64 就用 - 和 _ 取代了这两个字符，并且不会在末尾填充 = 号 Base64 隐写Base64 隐写就是利用解码时丢掉的数据进行信息隐藏，仍以下图为例子 因为上图加粗的零是编码时加上的，所以修改这些零对解码数据没有影响，但是 = 那里的零不能拿来修改，否则破坏了解码第一步，加粗的零作为最后一个字符的二进制组成部分，将被删除，不会影响还原。但是最后一个字符会发生变化。以上图为例， QkM&#x3D; ，QkN&#x3D; ，QkO&#x3D; ，QkP&#x3D; 最终都会还原成 BC 。 一个 Base64 编码的字符串最多有两个 =，1个 = 可以隐写2个 bit ，2个 = 可以隐写4个 bit 。 因为隐藏的信息有限，所以一般会给多行 base64 编码的字符串，每一行隐藏一部分，最终将这些信息拼接起来将得到隐写信息。 Base64 隐写解密脚本笔者发现网络流传的脚本不能直接使用，遂对其进行了修改，并以注释注明，使其能够在Windows下运行。（脚本的作者大概率是Mac用户） 环境：Win10+Python3.9 12345678910111213141516171819#!/usr/bin/env python3# -*- coding: utf-8 -*-__author__ = &#x27;Xiao&#x27;import base64base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;tmp.txt&#x27;, &#x27;rb&#x27;) as f: bin_str = &#x27;&#x27; for line in f.readlines(): stegb64 = str(line, &#x27;utf-8&#x27;).strip(&#x27;\\r\\n&#x27;) # Win下使用\\r\\n，Linux下使用\\n rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), &#x27;utf-8&#x27;).strip(&#x27;\\n&#x27;) offset = abs(base64chars.index(stegb64.replace(&#x27;=&#x27;, &#x27;&#x27;)[-1]) - base64chars.index(rowb64.replace(&#x27;=&#x27;, &#x27;&#x27;)[-1])) equalnum = stegb64.count(&#x27;=&#x27;) # no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) res = [chr(int(bin_str[i:i + 8], 2)) for i in range(0, len(bin_str), 8)] print(&#x27;&#x27;.join(res)) 代码解释base64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;相当于字典 with open(&#39;tmp.txt&#39;, &#39;rb&#39;) as f:是python提供的打开文件的方法，不需要关闭文件，即不需要写 f.close()。 “r” - 读取 - 默认值。打开文件进行读取，如果文件不存在则报错。 “b” - 二进制 - 二进制模式（例如图像）。 for line in f.readlines():readlines() 方法返回所有行，遍历每一行 bin_str = &#39;&#39;存储隐藏的flag stegb64 = str(line, &#39;utf-8&#39;).strip(&#39;\\r\\n&#39;)删除行末的换行符，strip()方法删除开头或结尾的字符，不能删除中间部分的字符。需要注意的是Win下使用\\r\\n，Linux下使用\\n rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), &#39;utf-8&#39;).strip(&#39;\\n&#39;)解码得到真实信息后再次编码，并删除行末的换行符 offset = abs(base64chars.index(stegb64.replace(&#39;=&#39;, &#39;&#39;)[-1]) - base64chars.index(rowb64.replace(&#39;=&#39;, &#39;&#39;)[-1]))计算偏离值，replace(&#39;=&#39;,&#39;&#39;)[-1]删除 = 并且返回最后一个字符；index() 方法返回字符在 base64chars 中的位置；abs() 返回2个偏离值相减的绝对值 equalnum = stegb64.count(&#39;=&#39;)计算 = 的数量 12if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) 如果等号的数量不为0表示隐藏了数据，将隐藏的数据转换成二进制以追加的方式存储到 bin_str 中。bin()方法返回一个整数 int 或者长整数 long int 的二进制表示。zfill()方法返回指定长度的字符串,原字符串右对齐,前面填充0。（笔者还未完全理解） res = [chr(int(bin_str[i:i + 8], 2)) for i in range(0, len(bin_str), 8)]（笔者仍未理解） print(&#39;&#39;.join(res))使用字符串的join方法，将列表中的元素用指定的分隔符（这里为空）连接起来，形成一个字符串 参考链接：https://www.cnblogs.com/asmurmur/p/14778548.html 题目：CTF-Misc-Base64隐写原题链接：https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99 笔者拿到该题，发现是 tar 文件。在 Windows 下直接解压，会出现元数据（meta data）的隐藏文件，导致解压后的文件不能正常打开。故需要在 Linux 下解压，使用如下命令 17z x attachment.tar 解压后的得到的 Comeon!.txt 中包含多行 base64 编码的字符串。笔者当时没有接触到Base64隐写的概念，误将多行 base64 编码的字符串进行了2次 base64 批量解码。最终得到了一串带有乱码的C语言代码。直接将解码结果以十六进制展示仍没有解决乱码问题。查询网络后得知Base64隐写的概念，遂有了本文 使用的脚本如下 将需要解密的文件复制到工作目录下，重命名为tmp.txt，运行脚本。需要注意的是需要解密的文件直接使用原文件","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"Crypto","slug":"Crypto","permalink":"https://waltyoung.github.io/tags/Crypto/"}]},{"title":"CTF-Misc-谁赢了比赛","slug":"CTF-Misc-谁赢了比赛","date":"2023-09-20T04:06:06.000Z","updated":"2023-09-20T04:07:21.493Z","comments":true,"path":"2023/09/20/CTF-Misc-谁赢了比赛/","link":"","permalink":"https://waltyoung.github.io/2023/09/20/CTF-Misc-%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B/","excerpt":"","text":"CTF-Misc-谁赢了比赛原题链接：https://buuoj.cn/challenges#%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B%EF%BC%9F 笔者拿到该题后，先使用十六进制编辑器确定了图片中存在隐藏文件，使用binwalk binwalk -e who_won_the_game.png --run-as=root提取文件，得到一个 rar 压缩包 由上图可见，压缩包内可见flag.txt 是未被加密的，hehe.gif 是被加密的。flag.txt 中的信息无效 检查 rar 压缩包的文件头、文件尾 由上图可见，rar 压缩包的文件头（52 61 72 21 1A 07 00）是正常的 由上图可见，rar 压缩包的文件头（C4 3D 7B 00 40 70 00）是正常的 在 rar 压缩包的十六进制文本里直接搜索 gif 图片的文件头（47 49 46 38），没有搜索到该文件头，因为压缩的本质是找出文件中字符串的概率分布，然后将出现概率高的字符串替换成更短的形式，所以猜测是真加密 笔者至此没有思路，经网络提醒，还有一种最后的方法——爆破 优先从4位纯数字开始爆破，幸运地得到了密码 使用密码解压后得到 gif 图片，先使用十六进制编辑器确定了图片中不存在隐藏文件，再置于 Stegsolve ，逐帧检查，在第310帧的时候发现了下图 另存改图为 bmp 文件（因为bmp 是未经过压缩的图像格式） 优先检查有无 LSB隐写，检查结果：无 但发现 Red 0平面包含了一张二维码，如下图所示 直接解码可得flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-来首歌吧","slug":"CTF-Misc-来首歌吧","date":"2023-09-19T05:09:00.000Z","updated":"2023-09-20T04:19:47.838Z","comments":true,"path":"2023/09/19/CTF-Misc-来首歌吧/","link":"","permalink":"https://waltyoung.github.io/2023/09/19/CTF-Misc-%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7/","excerpt":"","text":"CTF-Misc-来首歌吧原题链接：https://buuoj.cn/challenges#%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7 将 wav 文件置入 Audicity ，可观察到左声道特殊 放大后可见摩斯电码 逐个对照下表的摩斯电码，可以得到flag 本文重点在于介绍另一款音频隐写与提取工具————MP3Stego MP3Stego下载地址：https://www.petitcolas.net/fabien/software/ MP3Stego 提供图形化用户界面（即GUI）但为方便日后学习，笔者仍介绍在命令行下的使用方法 加密命令如下 1Encode -E data.txt -P pass sound.wav sound.mp3 参数解释 data.txt:需要加密的txt文件 pass:密码 sound.wav:需要将密码放入的wav文件) sound.mp3:需要解密的文件 解密命令如下 1Decode -X -P pass sound.mp3 参数解释 pass:密码 sound.mp3:需要解密的文件 需要注意的是 MP3Stego 只能分析、处理 MP3 文件（这也是本题使用不到 MP3Stego 的原因，即使本题的 wav 文件的文件名在诱导我们）","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-LSB隐写","slug":"CTF-Misc-LSB隐写","date":"2023-09-18T03:46:20.000Z","updated":"2023-09-18T03:47:56.622Z","comments":true,"path":"2023/09/18/CTF-Misc-LSB隐写/","link":"","permalink":"https://waltyoung.github.io/2023/09/18/CTF-Misc-LSB%E9%9A%90%E5%86%99/","excerpt":"","text":"CTF-Misc-LSB隐写名词解释MSB（Most Significant Bit）：最高有效位，二进制中代表最高值的比特位，这一位对数值的影响最大 LSB（Least Significant Bit）：最低有效位，二进制中代表最低值的比特位 例如，在二进制的1001（十进制的9）中，最左边的“1”即是MSB，最右边的“1”是LSB 常见CPU采用小端模式（Little-Endian）网络字节顺序采用大端模式（big endian）排序方式，TCP&#x2F;IP协议规定:接收到的第一个字节视作高位字节，这就要求发送端发送的第一个字节是高位字节。intel x86的CPU使用的是LE（Windows中称为“主机字节序”）,而SocksAddr中使用的则是BE（就是“网络字节序”），所以在使用网络编程时需要使用htns,htnl,nths,nthl来倒字节序 原理图片中的图像像素一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，即有256种颜色。LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化 原题隐写的内容不同，主要分为2种：字符和文件 原题链接：https://buuoj.cn/challenges#%E9%95%9C%E5%AD%90%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%96%E7%95%8C 工具： Stegsolve 如下图所示，可见隐写的内容是字符，即flag 原题链接：https://buuoj.cn/challenges#LSB 如下图所示，可见隐写的内容是 png 图片 将得到的 png 图片（即二维码）解码，解码平台————草料二维码解码器：https://cli.im/deqr/other 原题链接：https://buuoj.cn/challenges#FLAG 如下图所示，可见隐写的内容是 zip 压缩包（50 4b 03 04和PK的文件头，应及时反应是 zip 压缩包） 需要注意的是 0平面 可能隐写内容，1平面 也可能隐写内容 参考链接：https://zhuanlan.zhihu.com/p/461716971","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-N种方法解决","slug":"CTF-Misc-N种方法解决","date":"2023-09-16T16:15:27.000Z","updated":"2023-09-16T16:16:56.962Z","comments":true,"path":"2023/09/17/CTF-Misc-N种方法解决/","link":"","permalink":"https://waltyoung.github.io/2023/09/17/CTF-Misc-N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3/","excerpt":"","text":"CTF-Misc-N种方法解决原题链接：https://buuoj.cn/challenges#N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3 本题如题名有N种方法解决 方法一使用十六进制编辑器打开文件，可见 base64 编码的字符 文件尾也符合 base64 编码的特征，故将其间一整段字符使用 base64 解码。 需要注意的是 base64 解码的结果必须直接以十六进制展示，不能将 base64 解码得到的乱码复制到十六进制编辑器再计算其十六进制（后者的操作将导致数据不完整） 下图是正确解码的结果 复制结果，保存为 png 图片（89 50 4E 47是 PNG 的文件头） 得到一张二维码，置于草料二维码解码器https://cli.im/deqr/other解码 方法二PHP 内置很多 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 如下图所示，这是 PHP 伪协议的例子 本题中存在类似的 PHP 伪协议 直接将十六进制的字符复制到浏览器 得到一张二维码，置于草料二维码解码器https://cli.im/deqr/other解码","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-另外一个世界","slug":"CTF-Misc-另外一个世界","date":"2023-09-15T16:32:22.000Z","updated":"2023-09-15T16:33:46.217Z","comments":true,"path":"2023/09/16/CTF-Misc-另外一个世界/","link":"","permalink":"https://waltyoung.github.io/2023/09/16/CTF-Misc-%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C/","excerpt":"","text":"CTF-Misc-另外一个世界原题链接：https://buuoj.cn/challenges#%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C 笔者在做该题时，首先尝试了 Stegsolve，没有获得有效信息，然后打开了十六进制编辑器，在文件末尾发现了一段可疑的二进制序列。（需要注意的是查看文件的十六进制时，不仅需要关注到文件的头尾，而且在没有思路的时候需要关注到文件的中间部分，可能遗漏信息） 笔者没有思路，选择了看 wp (writeup)(笔者太笨了QAQ) 二进制序列以8位为一组，转换为十进制，再对照 ASCII 码表得出字符，最后以flag格式提交","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"}]},{"title":"CTF-Misc-zip伪加密","slug":"CTF-Misc-zip伪加密","date":"2023-09-15T04:15:30.000Z","updated":"2023-09-19T07:16:21.216Z","comments":true,"path":"2023/09/15/CTF-Misc-zip伪加密/","link":"","permalink":"https://waltyoung.github.io/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/","excerpt":"","text":"CTF-Misc-zip伪加密原题链接：https://buuoj.cn/challenges#zip%E4%BC%AA%E5%8A%A0%E5%AF%86 一个 ZIP 文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。 压缩源文件数据区： 50 4B 03 04：这是头文件标记，十六进制表示为PK 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 50 A3：最后修改文件时间 A5 4A：最后修改文件日期 21 38 76 64：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 08 00：文件名长度 00 00：扩展记录长度 压缩源文件目录区: 50 4B 01 02：目录中文件文件头标记 1F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 50 A3：最后修改文件时间 A5 4A：最后修改文件日期 21 38 76 65：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 08 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度 00 00：磁盘开始号 00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 压缩源文件目录结束标志: 50 4B 05 06：目录结束标记 00 00：当前磁盘编号 00 00：目录区开始磁盘编号 01 00：本磁盘上纪录总数 01 00：目录区中纪录总数 5A 00 00 00：目录区尺寸大小 3F 00 00 00：目录区对第一张磁盘的偏移量 00 00 00：ZIP 文件注释长度 文件数据区的全局方式位标记是文件头之后的第三个字节 文件目录区的全局方式位标记是文件头之后的第五个字节 无加密压缩源文件数据区的全局方式位标记应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00 假加密压缩源文件数据区的全局方式位标记应当为00 00且压缩源文件目录区的全局方式位标记应当为01 00 真加密压缩源文件数据区的全局方式位标记应当为01 00且压缩源文件目录区的全局方式位标记应当为01 00 全局方式位标记的四个数字中只有第二个数字对其有影响 第二个数字为奇数时，加密 第二个数字为偶数时，未加密 这是题目的原文件的十六进制 对照上文，将09 00全部修改为00 00，再次解压可得flag。（此处一定不是真加密，出题人将源文件数据区和目录区的全局方式位标记都修改了） 参考链接： https://blog.csdn.net/qq_32350719&#x2F;article&#x2F;details&#x2F;102661596 https://blog.csdn.net/qq_26187985&#x2F;article&#x2F;details&#x2F;83654197 笔者最初的笔记参考了伪教程，虽然当时的题目解决了，但是其他题目遇到问题了。鉴于网络的伪教程过多，说法不一致，所以笔者决定自己动手实验一遍 这是无加密的 zip 文件 这是真加密的 zip 文件 这是修改文件目录区的伪加密的 zip 文件 这是修改文件数据区的伪加密的 zip 文件 最终结果如下 与网络上的结论不同，只有修改文件数据区的全局方式位标记，才被提示加密了（可能与笔者使用的解压缩软件和 pkware 版本相关） 但在做题过程中确实遇到的是修改文件目录区，所以需要做更多的题目来验证 目前文件数据区和目录区的全局方式位标记都需要留意 文件数据区的全局方式位标记是文件头之后的第三个字节 文件目录区的全局方式位标记是文件头之后的第五个字节","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"}]},{"title":"NTFS交换数据流隐藏文件","slug":"NTFS交换数据流隐藏文件","date":"2023-09-14T03:47:47.000Z","updated":"2023-09-22T07:54:16.404Z","comments":true,"path":"2023/09/14/NTFS交换数据流隐藏文件/","link":"","permalink":"https://waltyoung.github.io/2023/09/14/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/","excerpt":"","text":"NTFS交换数据流隐藏文件 NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法看到非主文件的数据流。它使用资源派生来维持与文件相关的信息。在Windows下，文件名带有:的文件被视为NTFS流的非主文流，类似 Linux 的 swp 文件。 将 123 写入到 NTFS_demo.txt:1.txt 文件中 1echo 123 &gt; NTFS_demo.txt:1.txt 此时在文件中可见产生了一个 NTFS_demo.txt 文件，打开 NTFS_demo.txt 文件，可见是空白的 使用 notepad 命令打开 NTFS_demo.txt:1.txt 文件 1notepad NTFS_demo.txt:1.txt notepad 命令将唤起记事本，可见输入内容“123” 参考链接：https://www.qingsword.com/qing/812.html 如何检测和清除NTFS-ADS隐藏的文件： 对于压缩包类文件，可以使用压缩软件打开，在压缩软件中查看所需内容；也可以在Linux中直接解压该文件 合理利用工具，NTFS交换数据流检测工具的下载地址：https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/tools/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7.rar 需要注意的是，type命令执行 NTFS_demo.txt 文件和 NTFS_demo.txt:1.txt 文件的结果是不同的 type NTFS_demo.txt命令执行结果为空（因为NTFS_demo.txt文件中没有内容） type NTFS_demo.txt:1.txt命令执行结果如下所示 echo 命令和 type 命令存在显著差异 echo 命令是将字符写入到文件中 1echo 456 &gt;&gt; NTFS_demo.txt:1.txt type 命令是将已存在的文件用交换数据流的方式写到另外一个文件 1type 456.txt &gt;&gt; NTFS_demo.txt:1.txt 注：“&gt;&gt;”是追加重定向符号，与”&gt;”类似，但是会将命令的输出追加到文件的末尾，而不是覆盖文件内容。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"OS","slug":"OS","permalink":"https://waltyoung.github.io/tags/OS/"},{"name":"Forensics","slug":"Forensics","permalink":"https://waltyoung.github.io/tags/Forensics/"},{"name":"Windows","slug":"Windows","permalink":"https://waltyoung.github.io/tags/Windows/"}]},{"title":"记一次一句话木马的探索","slug":"记一次一句话木马的探索","date":"2023-09-13T07:28:35.000Z","updated":"2023-09-14T03:46:32.492Z","comments":true,"path":"2023/09/13/记一次一句话木马的探索/","link":"","permalink":"https://waltyoung.github.io/2023/09/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"记一次一句话木马的探索笔者在做CTF题时，发现了未曾见过的一句话木马┼攠數畣整爠煥敵瑳∨≡┩愾，就此展开探索 由网络可知这是ANSI 转 Unicode编码的 access 木马 ANSI是一种字符代码，对于不同语言来说，ANSI对应的编码是不同的 在中文系统中，使用ANSI保存，编码集是 GBK（MS936） 在日文系统中，使用ANSI保存，编码集是 Shift_JIS（MS932） 在CMD中可以使用chcp命令查看Windows当前的页面编码集，编码集根据时区选择。页面编码936在Win95及之前表示GB2312，在Win95之后表示GBK，需要注明的是GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。参考链接：https://blog.csdn.net/sxzlc/article/details/106203495这里提供查询页面编码的网址https://blog.csdn.net/sxzlc/article/details/106270405 UTF-16是一种编码方式，用于将Unicode字符转换为二进制数据。在UTF-16中，每个字符通常占用2个字节。 由于计算机存储数据的方式有两种：Big Endian（大端存储，高位低地址、低位高地址）和Little Endian（小端存储，低位低地址、高位高地址），因此在使用UTF-16编码时，需要通过在文件开头添加一个特殊字符来指示文件是使用Big Endian还是Little Endian的方式存储数据。这个特殊字符就是BOM（Byte Order Mark），它是一个Unicode字符，其编码为U+FEFF。 在 Windows 平台下，默认的Unicode编码为UTF-16 Little Endian，所以在UTF-16编码的文件开头会添加一个BOM字符（U+FEFF），以表示文件是以Little Endian方式存储数据。这个BOM字符在文件中的作用是告诉解码器如何正确地解析文件中的字符数据。 通过将木马复制粘贴到记事本，另存为5种不同编码方式的文件(ANSI、UTF-8、带有BOM的UTF-8、UTF-16 Big Endian、UTF-16 Little Endian)，再使用十六进制查看 由图可见，在UTF-16 Little Endian编码下可见正常的文字——&lt;% execute request(&quot;a&quot;)%&gt; 此处收集常见的一句话木马： https://blog.csdn.net/forest_fire&#x2F;article&#x2F;details&#x2F;50944437 https://www.cnblogs.com/goodgad/p/13463866.html","categories":[],"tags":[{"name":"记一次XXX","slug":"记一次XXX","permalink":"https://waltyoung.github.io/tags/%E8%AE%B0%E4%B8%80%E6%AC%A1XXX/"},{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"}]},{"title":"记一次开发过程中根据抓包和Request-Id（日志）排错","slug":"记一次开发过程中根据抓包和Request-Id（日志）排错","date":"2023-09-12T13:06:30.000Z","updated":"2023-09-12T13:09:47.447Z","comments":true,"path":"2023/09/12/记一次开发过程中根据抓包和Request-Id（日志）排错/","link":"","permalink":"https://waltyoung.github.io/2023/09/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%8A%93%E5%8C%85%E5%92%8CRequest-Id%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89%E6%8E%92%E9%94%99/","excerpt":"","text":"记一次开发过程中根据抓包和Request-Id（日志）排错笔者正在为https://waltyoung.github.io/movies/嵌入视频播放器，而后发现他人视频的URL有效，可以正常播放视频，但自己视频的URL无法正常播放视频，就此展开排错。 首先，笔者花费数个小时排除代码问题 其次，笔者又花费许久排除URL的问题（即腾讯云上存储的文件访问权限的问题） 再次，笔者又排除了网络环境问题（笔者确实发现网络环境不健康，但不是主要问题） 最后，笔者才考虑到抓包重新定位问题（笔者太笨了QAQ） 笔者的音乐和视频都存储在腾讯云上，但是笔者的音乐播放器正常工作，视频播放器未正常工作，所以对于二者分别抓包再做比较 笔者分析了抓包结果，发现以下两点： 返回码不同 腾讯云的自定义头的字段存在较大区别 针对第一点（返回码不同），视频播放器的返回码是206，笔者搜索、学习了返回码206代表的含义。HTTP 206 Partial Content成功状态响应代码指示请求已成功并且主体包含所请求的数据区间，该数据区间是在请求的 Range 字段指定的。可以简单地理解为返回码206是请求视频等大资源时的特定的返回码，因为用户不可能等待视频的完整传输完成，事实情况也是视频边下边播 针对第二点（腾讯云的自定义头的字段存在较大区别），二者的X-Cos-Request-Id值不同，并且未正常工作的视频播放器多一个X-Cos-Trace-Id字段 腾讯云上对于X-Cos-Request-Id和X-Cos-Trace-Id的解释如下 根据解释，笔者想到腾讯云的日志也可以帮助分析问题（笔者没有找到腾讯云对象存储服务的日志，但是找到了自助诊断工具） 如图所示，找到跨域访问设置，解决问题 总结： 从想到抓包至问题解决，只用了不到一个小时，远低于排除代码、文件权限问题的耗时，所以选择合适合理的方法定位、分析问题非常重要。当然，无关问题的排除也很重要","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"https://waltyoung.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"记一次XXX","slug":"记一次XXX","permalink":"https://waltyoung.github.io/tags/%E8%AE%B0%E4%B8%80%E6%AC%A1XXX/"}]},{"title":"WHERE、CHECK、HAVING的区别","slug":"WHERE、CHECK、HAVING的区别","date":"2023-09-06T16:09:44.000Z","updated":"2023-09-06T16:11:12.522Z","comments":true,"path":"2023/09/07/WHERE、CHECK、HAVING的区别/","link":"","permalink":"https://waltyoung.github.io/2023/09/07/WHERE%E3%80%81CHECK%E3%80%81HAVING%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"WHERE、CHECK、HAVING的区别在T-SQL语言中，WHERE、CHECK、HAVING都是用于筛选数据的关键字，但它们的使用场景和作用略有不同。 WHERE：WHERE用于在SELECT、UPDATE、DELETE等语句中筛选数据，它是一个过滤器，可以根据指定的条件从表中选择符合条件的记录。WHERE子句可以包含多个条件，多个条件之间可以使用AND或OR进行连接。WHERE子句不能使用聚合函数。**常见的聚合函数如下：count()、sum()、avg()、min()、max()**。 CHECK：CHECK用于在创建表时定义列的约束条件，它可以限制列中的数据必须满足指定的条件。例如，可以使用CHECK约束限制某个列的取值范围、数据类型、长度等。CHECK约束可以在创建表时定义，也可以在ALTER TABLE语句中添加。 HAVING：HAVING用于在GROUP BY子句中筛选数据，它是一个过滤器，可以根据指定的条件从分组后的结果集中选择符合条件的记录。HAVING子句可以包含多个条件，多个条件之间可以使用AND或OR进行连接。 总的来说，WHERE用于在SELECT、UPDATE、DELETE等语句中筛选数据，CHECK用于在创建表时定义列的约束条件；HAVING用于在GROUP BY子句中筛选数据，HAVING必须写在GROUP BY之后，例GROUP BY kind HAVING num &gt; 3。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"SQL","slug":"SQL","permalink":"https://waltyoung.github.io/tags/SQL/"}]},{"title":"WHERE子句可后接的关键字","slug":"WHERE子句可后接的关键字","date":"2023-09-05T16:51:31.000Z","updated":"2023-09-05T16:53:46.462Z","comments":true,"path":"2023/09/06/WHERE子句可后接的关键字/","link":"","permalink":"https://waltyoung.github.io/2023/09/06/WHERE%E5%AD%90%E5%8F%A5%E5%8F%AF%E5%90%8E%E6%8E%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"WHERE子句可以后接以下关键字： AND：用于连接多个条件，要求同时满足所有条件。 OR：用于连接多个条件，只要满足其中一个条件即可。 NOT：用于否定一个条件。 IN：用于指定一个范围，判断某个值是否在这个范围内。 BETWEEN：用于指定一个范围，判断某个值是否在这个范围内。 LIKE：用于模糊匹配，判断某个值是否符合指定的模式。 IS NULL：用于判断某个值是否为空。 EXISTS：用于判断子查询是否返回结果。 ANY&#x2F;SOME：用于判断某个值是否与子查询中的任意一个值相等。 ALL：用于判断某个值是否与子查询中的所有值都相等。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"SQL","slug":"SQL","permalink":"https://waltyoung.github.io/tags/SQL/"}]},{"title":"LEFT JOIN与JOIN的区别","slug":"LEFT-JOIN与JOIN的区别","date":"2023-09-05T07:04:10.000Z","updated":"2023-09-05T07:06:21.778Z","comments":true,"path":"2023/09/05/LEFT-JOIN与JOIN的区别/","link":"","permalink":"https://waltyoung.github.io/2023/09/05/LEFT-JOIN%E4%B8%8EJOIN%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"LEFT JOIN与JOIN的区别在SQL中，JOIN是连接两个或多个表的操作，而LEFT JOIN是其中一种JOIN的类型。 JOIN操作会返回两个表中匹配的行，如果两个表中没有匹配的行，则不会返回任何结果。而LEFT JOIN操作会返回左表中的所有行，即使在右表中没有匹配的行，左表中的行也会被返回，右表中没有匹配的列则会用NULL填充。 举个例子，假设有两个表A和B，A表中有3行数据，B表中有2行数据，其中一行数据的ID与A表中的一行数据的ID相同，另一行数据的ID与A表中的任何一行数据的ID都不相同。使用JOIN操作，只会返回一行数据，即A表中ID与B表中ID相同的那行数据。而使用LEFT JOIN操作，则会返回A表中的所有3行数据，其中一行数据与B表中的那行数据匹配，另外两行数据的B表中的列则会用NULL填充。 因此，LEFT JOIN操作可以保证左表中的所有数据都会被返回，即使在右表中没有匹配的数据。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"SQL","slug":"SQL","permalink":"https://waltyoung.github.io/tags/SQL/"}]},{"title":"PKCS5padding和PKCS7padding的区别","slug":"PKCS5padding和PKCS7padding的区别","date":"2023-09-04T07:38:32.000Z","updated":"2023-09-15T04:14:52.242Z","comments":true,"path":"2023/09/04/PKCS5padding和PKCS7padding的区别/","link":"","permalink":"https://waltyoung.github.io/2023/09/04/PKCS5padding%E5%92%8CPKCS7padding%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"PKCS5padding和PKCS7padding的区别PKCS5padding和PKCS7padding（PKCS7padding是PKCS#7填充的简称，PKCS#7是密码学标准PKCS（Public Key Cryptography Standards）中定义的填充方案，用于在加密算法中对数据进行填充。）是两种常见的填充方案，用于在加密前将数据块的大小调整为加密算法所要求的固定大小。它们在填充字节的值和填充方式上有一些区别。 PKCS5padding： 填充字节的值等于需要填充的字节数。 如果需要填充的字节数为n，则填充n个字节，每个字节的值为n。 例如，如果需要填充2个字节，那么填充的字节为0x02 0x02。 PKCS7padding： 填充字节的值等于需要填充的字节数。 如果需要填充的字节数为n，则填充n个字节，每个字节的值为n。 与PKCS5padding的区别在于，PKCS7padding可以用于任意块大小的加密算法，而不仅限于PKCS5padding的8字节块大小。 例如，如果需要填充2个字节，那么填充的字节为0x02 0x02。 总结：PKCS5padding和PKCS7padding在填充字节的值和填充方式上略有不同，但在实际应用中，它们通常可以互相替换使用。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Crypto","slug":"Crypto","permalink":"https://waltyoung.github.io/tags/Crypto/"}]},{"title":"UEFI和BIOS的区别","slug":"UEFI和BIOS的区别","date":"2023-09-03T05:30:15.000Z","updated":"2023-09-15T04:13:19.386Z","comments":true,"path":"2023/09/03/UEFI和BIOS的区别/","link":"","permalink":"https://waltyoung.github.io/2023/09/03/UEFI%E5%92%8CBIOS%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"UEFI和BIOS的区别UEFI（统一的可扩展固件接口）和BIOS（基本输入&#x2F;输出系统）都是计算机的固件接口，用于启动和管理计算机的硬件和软件。 BIOS是一种旧的固件接口，它是在计算机启动时首先加载的。它负责初始化和检测计算机的硬件设备，例如处理器、内存、硬盘等，并将控制权交给操作系统。BIOS还包含一个小型的操作系统，称为CMOS（可编程只读存储器），用于存储计算机的基本设置，例如日期、时间、启动顺序等。 UEFI是一种更新的固件接口，它取代了传统的BIOS。UEFI提供了更先进的功能和更好的兼容性。与BIOS相比，UEFI具有以下优势： 容量更大：UEFI支持更大的固件容量，可以容纳更多的功能和驱动程序。 启动速度更快：UEFI的启动速度比BIOS更快，因为它在启动时不需要进行硬件初始化和自检。 更好的兼容性：UEFI可以更好地与现代操作系统和硬件设备兼容，支持更多的文件系统和硬件接口。 图形界面：UEFI提供了一个图形界面，使用户可以更直观地设置计算机的启动选项和其他设置。 总的来说，UEFI是一种更先进、更灵活和更可扩展的固件接口，它取代了传统的BIOS，并提供了更好的启动速度和兼容性。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"OS","slug":"OS","permalink":"https://waltyoung.github.io/tags/OS/"}]},{"title":"HW避雷","slug":"HW避雷","date":"2023-09-02T01:21:45.000Z","updated":"2023-09-02T01:22:57.823Z","comments":true,"path":"2023/09/02/HW避雷/","link":"","permalink":"https://waltyoung.github.io/2023/09/02/HW%E9%81%BF%E9%9B%B7/","excerpt":"","text":"被坑的护网(HW, HVV, 国护)经历&amp;套路分享，保持警惕！本文系转载，原文链接https://github.com/venkatorne/HVV_Share&#x2F;blob&#x2F;main&#x2F;HW%E9%81%BF%E9%9B%B7.md 欢迎PR，关键信息请打码或变声，注意不要泄露隐私或恶意破坏他人声誉！可不分享真实案例，只提供套路，能少一个师傅被坑都是好事! 欢迎Star与分享，让更多人看到!为众人抱薪者，不可使其冻毙于风雪。 承诺安排项目锁人，最终安排少量夜班工作天数，提出疑问视为拒绝项目核心套路承诺安排项目，但安排不下去（中介和厂商都有可能），卡在护网前一两天安排项目，每人安排少量夜班工作天数，提出疑问（非明确拒绝）则视为不接受项目，无需承担任何责任！ 极端例子（理论上） 中介或厂商承诺了项目但人安排不下去，护网15天里一人一天夜班，一个人的工作可以直接安排15人，有疑议（甚至不需要表示拒绝）就视为不接受直接释放，快速的继续安排下个人，且责任在于师傅个人。 同时中介不包差旅，一天工资甚至不够路费，为了不付费上班，只能明确拒绝项目，中介&#x2F;厂商无责，甚至可能追责师傅个人不服从安排导致项目出现问题进行索赔。 卡在护网前一天安排项目，让师傅没有选择的余地 中介可能存在的好处 可接近无责大量锁人到护网前甚至结束 优先选择价低的师傅去安排，赚更多中介费，剩下的约等于无责释放 道德混淆：是师傅嫌弃项目不服从安排，而不是中介&#x2F;厂商不安排，立于道德与法律上的不败之地。（如：甚至都没分配到项目&#x2F;项目黄了都没说，你还嫌天数少，活该！） 真实案例分享涉及对象（只为便于理解，某些人请不要自行代入） 中介 公司：成都宏******公司（可能改名）、统一社会信用代码：915Y2R 拉群微信：春（Cl0***） 对接人 微信：*刘（xsy***）、名称：杰、联系方式：*2712 厂商：某数字公司 项目经理(疑似)：*志 核心时间线 6.25 发布需求：某数字公司第三批招人，提前进场 6.25 中介面 6.27 厂商面 6.28 中介表示没过提前进场，但厂商锁人，承诺优先安排提前进场按80%算工资，正式护网15天 6.29 11:29 问询不定岗违约责任，中介表示违约责任是厂商定 6.29 11:39 厂商人员打电话，中间厂商人员承诺定岗 6.29 15:08 跟中介签订合同 7.31 跟中介问询项目分配 8.7 19:53 （开始前两天晚上） 分配项目进群 8.7 22:10 跟项目经理确认只能排7天或8天夜班 8.7 22:12 跟中介问询天数，中介表示他去协调 8.7 22:22 项目经理突然跟我表示：你考虑下其他项目，我这边没这么多空余人天 8.7 22:23 截图发给中介，中介表示客户把我pass了，换人了（我跟中介与项目经理均未表示拒绝该项目） 8.7 22:31 中介表示换项目，需要等明天(8.8日)安排 8.8 整日未回消息 8.9 中介表示：你被释放了 8.9 与中介沟通，索要补偿或安排新项目，被拒绝&#x2F;无视 8.10 中介踢群+拉黑 相关证据 6.25 发布需求：某数字公司第三批招人，提前进场 6.28 中介表示没过提前进场，但厂商锁人，承诺优先安排提前进场按80%算工资，正式护网15天 6.29 11:29 问询不定岗违约责任，中介表示违约责任是厂商定 6.29 11:39 厂商人员打电话，中间厂商人员承诺定岗 https://github.com/venkatorne/HVV_Share/assets/141924762/0658cb4b-ffc9-4d8d-9244-af9ab3b9508d 7.31 跟中介问询项目分配 8.7 19:53 （开始前两天晚上） 分配项目进群 8.7 22:10 跟项目经理确认只能排7天或8天夜班 8.7 22:12 跟中介问询天数，中介表示他去协调 8.7 22:22 项目经理突然跟我表示：你考虑下其他项目，我这边没这么多空余人天 8.7 22:23 截图发给中介，中介表示客户把我pass了，换人了（我跟中介与项目经理均未表示拒绝该项目） 8.7 22:31 中介表示换项目，需要等明天(8.8日)安排 8.8 整日未回消息 8.9 中介表示：你被释放了 8.10 中介踢群+拉黑 个人感受整个心态爆炸，恶心坏了：面提前进场，结果没提前进场；说优先安排提前进场，护网开始前2天才分配项目；说好15天，一开排班7天夜班；（提前进场赚钱-&gt;只给赚7天钱）；中介表示协调，结果我还没说拒绝项目呢，就直接光速换人；（只给赚7天钱-&gt;滚）；中介说换项目，结果白等一天（护网开始前1天）；护网开始第1天跟我说被释放了；（滚-&gt;完美浪费掉你找其他项目的时间）；要求补偿&#x2F;安排项目，直接被拒绝甚至无视，最终拉黑。只能说太牛逼了，这种活该财源广进！ 规避手段 合同约定最少工作天数与保证定岗&#x2F;安排项目 不要理会任何口头承诺（电话&#x2F;微信聊天），只有写进合同才有效 约定违约赔偿金额 不要轻信根据厂商决定&#x2F;按厂商的违约来定的话术，不要轻信厂商承诺 违约是你跟中介的事，找中介麻烦，中介推脱是厂商责任也要让中介去找厂商，不要自己去找厂商 避雷特定中介","categories":[],"tags":[{"name":"HW","slug":"HW","permalink":"https://waltyoung.github.io/tags/HW/"},{"name":"转载","slug":"转载","permalink":"https://waltyoung.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"成为未来的管理者之前的笔记","slug":"成为未来的管理者之前的笔记","date":"2023-08-31T16:58:58.000Z","updated":"2023-08-31T17:01:01.416Z","comments":true,"path":"2023/09/01/成为未来的管理者之前的笔记/","link":"","permalink":"https://waltyoung.github.io/2023/09/01/%E6%88%90%E4%B8%BA%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E4%B9%8B%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0/","excerpt":"","text":"成为未来的管理者之前的笔记 不辞退不够强的人，是对其他正在付出的人的不尊重 盲目换人从来不解决本质问题 有效量化，降低信息差，是企业运作的核心 搭建适合自己的信息系统（工具：飞书、共享文档） 会议优化（具体执行方法：在开会之前采用协作文档，共同记录信息；会议开始后，所有人静默10min阅读文档，有疑点的地方直接批注，在线交流；之后的会议只讨论批注的问题。目的：压缩会议时长，避免侃大山，减小部门间的信息差） 人性是经不起挑战的，商业，是切蛋糕的艺术，即利益分配要合理 OKR体系：全称是 Objectives &amp; Key Results，即目标与关键成果。 O是努力的方向和目标，概念意义上的，代表你到底要去哪里 KR是理想结果，必须可量化，具体到面向个人，代表具体怎么去 参考链接：https://zhuanlan.zhihu.com/p/265830351 内容创作者不要把自己当回事（对于内容创作者需要知道的行业规则之一：和代理有效沟通“返点”问题） 一个优秀的视频应当具备的要素：HKRR（H：Happiness，K：Knowledge，R：Resonance，R：Rhythm） 电影行业的技巧————时钟理论：将视频的时长作为圆的周长，标出0点、3点、6点、9点的内容，如果这四个点没有爆点，那么必须修改，尽可能让刺激点充满整个时钟。目的：可视化视频节奏 不融资的话，团队人数上限不应超过20人 不要留恋成功的一刻，不要躺在功劳簿上享福","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"https://waltyoung.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"管理","slug":"管理","permalink":"https://waltyoung.github.io/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"网络安全成长路径","slug":"网络安全成长路径","date":"2023-08-31T05:08:06.000Z","updated":"2023-08-31T17:00:35.140Z","comments":true,"path":"2023/08/31/网络安全成长路径/","link":"","permalink":"https://waltyoung.github.io/2023/08/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84/","excerpt":"","text":"网络安全成长路径 学习“小迪安全-渗透测试”的课程 考证：软考（中级信息安全工程师）、CISP（CISP-PTE、CISP-PTS）、OSCP 获取CNVD证书 SRC平台挖漏洞 写一个GitHub项目 搭建一个blog站，记录学习过程与经历，如记一次XXX或记一次XXX到XXX 参加CTF比赛 参考链接：https://blog.csdn.net/m0_67286096&#x2F;article&#x2F;details&#x2F;124020811","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"https://waltyoung.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"网络安全","slug":"网络安全","permalink":"https://waltyoung.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"CMD的常见符号及其作用","slug":"CMD的常见符号及其作用","date":"2023-08-30T01:58:41.000Z","updated":"2023-09-21T16:27:46.058Z","comments":true,"path":"2023/08/30/CMD的常见符号及其作用/","link":"","permalink":"https://waltyoung.github.io/2023/08/30/CMD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AC%A6%E5%8F%B7%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/","excerpt":"","text":"Q：tasklist | findstr &quot;cmd&quot;此命令中的“|”是什么作用？ A：在CMD中，”|”（管道符号）的作用是将前一个命令的输出作为后一个命令的输入。在给出的命令中，”tasklist”命令用于列出当前正在运行的进程列表，而”findstr”命令用于在输出结果中查找包含指定字符串（在此例中是”cmd”）的行。所以整个命令的作用是列出当前正在运行的进程列表，并在结果中筛选出包含”cmd”字符串的行。 CMD的常见符号及其作用 ： “&gt;”：重定向符号。用于将命令的输出重定向到文件。例如，”dir &gt; output.txt”将”dir”命令的输出保存到名为”output.txt”的文件中。 “&gt;&gt;”：追加重定向符号。与”&gt;”类似，但是会将命令的输出追加到文件的末尾，而不是覆盖文件内容。 “&lt;”：输入重定向符号。用于将文件中的内容作为命令的输入。例如，”sort &lt; input.txt”将”input.txt”文件中的内容作为”sort”命令的输入进行排序。 “&amp;”：命令分隔符。用于在一行中运行多个命令。例如，”command1 &amp; command2”将依次执行”command1”和”command2”。 “&amp;&amp;”：条件命令分隔符。只有前一个命令成功执行后，才会执行后续的命令。例如，”command1 &amp;&amp; command2”只有在”command1”成功执行后，才会执行”command2”。 “||”：条件命令分隔符。只有前一个命令执行失败后，才会执行后续的命令。例如，”command1 || command2”只有在”command1”执行失败后，才会执行”command2”。 这些符号可以帮助您在CMD下更有效地执行命令和操作。请注意，有些符号在不同的操作系统或命令行环境中可能会有不同的行为。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"OS","slug":"OS","permalink":"https://waltyoung.github.io/tags/OS/"},{"name":"Windows","slug":"Windows","permalink":"https://waltyoung.github.io/tags/Windows/"}]},{"title":"不同操作系统对待换行符的不同态度","slug":"不同操作系统对待换行符的不同态度","date":"2023-08-29T01:18:17.000Z","updated":"2023-09-21T16:26:36.334Z","comments":true,"path":"2023/08/29/不同操作系统对待换行符的不同态度/","link":"","permalink":"https://waltyoung.github.io/2023/08/29/%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%BE%85%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%80%81%E5%BA%A6/","excerpt":"","text":"不同操作系统对待换行符的主要区别在于使用的字符不同。 在Windows操作系统中，换行符由两个字符组成：回车符（CR）和换行符（LF），表示为”\\r\\n”。 在Unix&#x2F;Linux操作系统中，换行符只有一个字符：换行符（LF），表示为”\\n”。 在Macintosh操作系统中，换行符只有一个字符：回车符（CR），表示为”\\r”。 这些差异可能会导致在不同操作系统之间传输文本文件时出现格式问题。","categories":[],"tags":[{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"OS","slug":"OS","permalink":"https://waltyoung.github.io/tags/OS/"},{"name":"Windows","slug":"Windows","permalink":"https://waltyoung.github.io/tags/Windows/"},{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"}]},{"title":"DoS压力测试工具——Slowhttptest","slug":"DoS压力测试工具——Slowhttptest","date":"2023-08-28T04:31:32.000Z","updated":"2023-09-03T05:52:46.096Z","comments":true,"path":"2023/08/28/DoS压力测试工具——Slowhttptest/","link":"","permalink":"https://waltyoung.github.io/2023/08/28/DoS%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Slowhttptest/","excerpt":"","text":"DoS压力测试工具——Slowhttptest安装命令：apt-get install slowhttptest 使用方法：ulimit -n 8000 &amp;&amp; slowhttptest -c 8000 -X -r 100 -g -o / -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://caichuanqi.cn -p 3 参考链接：https://caichuanqi.blog.csdn.net/article/details/124744284","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://waltyoung.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"云服务器上基于Docker搭建AWVS教程","slug":"AWVS安装教程","date":"2023-07-09T11:42:07.000Z","updated":"2023-08-28T01:37:06.675Z","comments":true,"path":"2023/07/09/AWVS安装教程/","link":"","permalink":"https://waltyoung.github.io/2023/07/09/AWVS%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"第0步：系统更新笔者使用的Linux系统是Debian 11.1 64bit。 切换到root用户，并且注意全程使用root用户 1su 更新软件包列表 1apt-get update 进行一次升级 1apt-get upgrade 第1步：安装Docker安装docker和docker-compose 1apt-get install docker docker-compose 安装Docker依赖 1apt-get install docker.io 安装完成后使用如下命令检查安装是否成功 1docker -v 第2步：安装AWVS拉取Docker镜像 1docker pull quay.io/hiepnv/acunetix 创建名为acunetix_data的Docker卷 1docker volume create acunetix_data 运行acunetix_web的容器 1docker run -d -p 3443:3443 --restart=unless-stoped --name=acunetix_web quay.io/hiepnv/acunetix 第3步：开放端口云服务器防火墙开放端口，个人使用可以全部开放，如有必要则可以选择只开放3443端口 第4步：测试必须通过HTTPS访问3443端口 默认账户：&#x61;&#100;&#x6d;&#105;&#x6e;&#64;&#x61;&#x63;&#117;&#x2e;&#x63;&#111;&#109; 默认密码：Passw0rd!","categories":[],"tags":[{"name":"AWVS","slug":"AWVS","permalink":"https://waltyoung.github.io/tags/AWVS/"},{"name":"安装教程","slug":"安装教程","permalink":"https://waltyoung.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"基于Hexo框架搭建个人博客教程","slug":"基于Hexo框架搭建个人博客教程","date":"2023-06-17T09:16:19.000Z","updated":"2023-08-28T01:37:27.486Z","comments":true,"path":"2023/06/17/基于Hexo框架搭建个人博客教程/","link":"","permalink":"https://waltyoung.github.io/2023/06/17/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","excerpt":"","text":"本文前置技能：虚拟机的安装与初始化，Linux操作系统基础 第0步：系统更新笔者使用的Linux系统是Ubuntu LTS22.0.4。所有使用Debian内核的Linux都可遵循本教程。 切换到root用户，并且注意全程使用root用户 1su 更新软件包列表 1apt-get update 进行一次升级 1apt-get upgrade 第1步：安装Git注意使用root用户 1apt-get install git 安装完成后使用如下命令检查安装是否成功 1git --version 第2步：安装Nodejs注意使用root用户 12apt-get install nodeapt-get install npm 安装完成后使用如下命令检查安装是否成功 12node -vnpm -v 第3步：安装及初始化Hexo注意使用root用户 1npm install -g hexo-cli 安装完成后使用如下命令检查安装是否成功 1hexo -v 初始化Hexo 1hexo init 启动服务 1hexo s 在终端中右键打开链接http://localhost:4000/打开Hexo生成的默认网页 未完待续…","categories":[],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"https://waltyoung.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://waltyoung.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-06-14T16:55:48.726Z","updated":"2023-06-14T16:55:48.726Z","comments":true,"path":"2023/06/15/hello-world/","link":"","permalink":"https://waltyoung.github.io/2023/06/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://waltyoung.github.io/tags/SQL/"},{"name":"Linux","slug":"Linux","permalink":"https://waltyoung.github.io/tags/Linux/"},{"name":"成长","slug":"成长","permalink":"https://waltyoung.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"记一次XXX","slug":"记一次XXX","permalink":"https://waltyoung.github.io/tags/%E8%AE%B0%E4%B8%80%E6%AC%A1XXX/"},{"name":"Python","slug":"Python","permalink":"https://waltyoung.github.io/tags/Python/"},{"name":"Code Review","slug":"Code-Review","permalink":"https://waltyoung.github.io/tags/Code-Review/"},{"name":"Selenium","slug":"Selenium","permalink":"https://waltyoung.github.io/tags/Selenium/"},{"name":"Go","slug":"Go","permalink":"https://waltyoung.github.io/tags/Go/"},{"name":"C/C++","slug":"C-C","permalink":"https://waltyoung.github.io/tags/C-C/"},{"name":"PAT","slug":"PAT","permalink":"https://waltyoung.github.io/tags/PAT/"},{"name":"ACM","slug":"ACM","permalink":"https://waltyoung.github.io/tags/ACM/"},{"name":"CTF","slug":"CTF","permalink":"https://waltyoung.github.io/tags/CTF/"},{"name":"Reverse","slug":"Reverse","permalink":"https://waltyoung.github.io/tags/Reverse/"},{"name":"Misc","slug":"Misc","permalink":"https://waltyoung.github.io/tags/Misc/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://waltyoung.github.io/tags/Wireshark/"},{"name":"DP","slug":"DP","permalink":"https://waltyoung.github.io/tags/DP/"},{"name":"安装教程","slug":"安装教程","permalink":"https://waltyoung.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"name":"Crypto","slug":"Crypto","permalink":"https://waltyoung.github.io/tags/Crypto/"},{"name":"Windows","slug":"Windows","permalink":"https://waltyoung.github.io/tags/Windows/"},{"name":"PE","slug":"PE","permalink":"https://waltyoung.github.io/tags/PE/"},{"name":"Java","slug":"Java","permalink":"https://waltyoung.github.io/tags/Java/"},{"name":"隐写","slug":"隐写","permalink":"https://waltyoung.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"Vim","slug":"Vim","permalink":"https://waltyoung.github.io/tags/Vim/"},{"name":"OS","slug":"OS","permalink":"https://waltyoung.github.io/tags/OS/"},{"name":"Forensics","slug":"Forensics","permalink":"https://waltyoung.github.io/tags/Forensics/"},{"name":"每天一个小知识点","slug":"每天一个小知识点","permalink":"https://waltyoung.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"HW","slug":"HW","permalink":"https://waltyoung.github.io/tags/HW/"},{"name":"转载","slug":"转载","permalink":"https://waltyoung.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"管理","slug":"管理","permalink":"https://waltyoung.github.io/tags/%E7%AE%A1%E7%90%86/"},{"name":"网络安全","slug":"网络安全","permalink":"https://waltyoung.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"工具","slug":"工具","permalink":"https://waltyoung.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"AWVS","slug":"AWVS","permalink":"https://waltyoung.github.io/tags/AWVS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://waltyoung.github.io/tags/Hexo/"}]}