<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF-Reverse-Java_Tools</title>
      <link href="/2023/09/25/CTF-Reverse-Java-Tools/"/>
      <url>/2023/09/25/CTF-Reverse-Java-Tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Reverse-Java-Tools"><a href="#CTF-Reverse-Java-Tools" class="headerlink" title="CTF-Reverse-Java_Tools"></a>CTF-Reverse-Java_Tools</h1><p>原题链接：<a href="https://www.polarctf.com/#/page/challenges">https://www.polarctf.com/#/page/challenges</a>的Java_Tools</p><p>笔者拿到该题，发现是 jar 文件，优先置于 jd-gui.exe 反编译。可见如下两个文件</p><p><img src="https://s2.loli.net/2023/09/23/RGZgQeM9WzIl5VC.png" alt="jar 文件内容.png"></p><p>Test.java 文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;Welcome to Polar_Ctf!,come to play!&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Please Input : &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.next();</span><br><span class="line">    <span class="type">char</span>[] Strings = name.toCharArray();</span><br><span class="line">    Tools.Add_1(Strings, <span class="number">3</span>);</span><br><span class="line">    Tools.Re(Strings);</span><br><span class="line">    Tools.Judge(Strings);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tools.java 文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Re</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length / <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> str[i];</span><br><span class="line">      str[i] = str[str.length - i - <span class="number">1</span>];</span><br><span class="line">      str[str.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Xor</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)</span><br><span class="line">      str[i] = (<span class="type">char</span>)(str[i] ^ j); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Add_1</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)</span><br><span class="line">      str[i] = (<span class="type">char</span>)(str[i] + x); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Judge</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">    ArrayList&lt;Character&gt; Result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Character&gt; Flag = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] arrayOfChar1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">byte</span> b;</span><br><span class="line">    <span class="keyword">for</span> (arrayOfChar1 = str, i = arrayOfChar1.length, b = <span class="number">0</span>; b &lt; i; ) &#123;</span><br><span class="line">      <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> Character.valueOf(arrayOfChar1[b]);</span><br><span class="line">      Result.add(Character.valueOf(character.charValue()));</span><br><span class="line">      b++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;$gourZroohK&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sttr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (name.contains(sttr)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;You Are Right!MD5!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;You Are Wrong! please try it again!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">char</span>[] Strings = name.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : Strings)</span><br><span class="line">      Flag.add(Character.valueOf(c)); </span><br><span class="line">    <span class="keyword">if</span> (Result.equals(Flag)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;You Are Right!MD5!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;You Are Wrong! please try it again!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然可见 Test.java 调用 Tools.java 的方法，直接阅读代码可知 Add_1 方法是默认情况的凯撒加密， Re 方法是互换位置， Judge 方法是判断输入是否正确， Xor 方法没有使用</p><p>实战或比赛中，可以对代码稍加分析后立即调试，在调试中观察代码的执行情况</p><p>为了便于调试，我们可以将源文件置于 IDEA 项目的 <code>src</code> 目录下，并且重命名 Test.java 为 Main.java，删除每个java文件的第一行<code>package main.java</code></p><p>如图所示java文件位置</p><p><img src="https://s2.loli.net/2023/09/24/MrQCA1YFlP2S9yD.png" alt="java文件位置.png"></p><p>以<code>12345678</code>为输入，作示例</p><p>下图是步入 Add_1 函数前，Strings数组的内容就是笔者的输入</p><p><img src="https://s2.loli.net/2023/09/23/PvJ4c2dorhiAlDy.png" alt="示例：步入Add_1函数前.png"></p><p>下图是步出 Add_1 函数后即步入 Re 函数前，Strings数组的内容是笔者的输入经过偏移值为3的凯撒加密后的结果</p><p><img src="https://s2.loli.net/2023/09/23/u3ZNAxdDvzypolS.png" alt="示例：步出Add_1函数后即步入Re函数前.png"></p><p>下图是步出 Re 函数后即步入 Judge 函数前，Strings数组的内容是步入Re函数前的数组 头尾互换。（<em>具体细节情读者自行查看，笔者表述能力不太好QAQ）</em></p><p><img src="https://s2.loli.net/2023/09/23/qrZugJd7pUDnT3A.png" alt="示例：步出Re函数后.png"></p><p>笔者接下来将图文结合逐行解释代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Character&gt; Result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Character&gt; Flag = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如上代码的作用是新建 Result 、 Flag 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (arrayOfChar1 = str, i = arrayOfChar1.length, b = <span class="number">0</span>; b &lt; i; ) &#123;</span><br><span class="line">  <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> Character.valueOf(arrayOfChar1[b]);</span><br><span class="line">  Result.add(Character.valueOf(character.charValue()));</span><br><span class="line">  b++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码的作用是复制步入 Judge 函数前 Strings数组的内容到 Result 数组</p><p>调试时也可验证如上代码的作用，下图是Result数组的内容， Result 数组的内容和 str 数组、步入 Judge 函数前 Strings数组的内容完全相同</p><p><img src="https://s2.loli.net/2023/09/24/fMwt91QJR4PShHI.png" alt="Result数组的内容.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;$gourZroohK&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sttr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str); </span><br></pre></td></tr></table></figure><p>如上代码的作用是第一行，创建一个 String 类型的变量 name，并赋值<code>$gourZroohK</code>；第二行，将传入的数组 str 转化为 String 类型的字符串，并保存到 String 类型的变量sttr 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name.contains(sttr)) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;You Are Right!MD5!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;You Are Wrong! please try it again!&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如上代码的作用是判断 sttr 是否包含在 name 中。关键方法是contains()。*(与下一段代码相比，不是很重要)*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] Strings = name.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : Strings)</span><br><span class="line">  Flag.add(Character.valueOf(c)); </span><br></pre></td></tr></table></figure><p>如上代码的作用是第一行，将 name 字符串转化为 char 类型的数组，并保存到 char 类型的 Strings 数组中；第二行，for 语句的作用的本质是复制第一行的 Strings数组的内容到 Flag 数组中</p><p>调试时也可验证如上代码的作用，下图是 Flag 数组的内容， Flag 数组的内容和 Strings数组的内容完全相同</p><p><img src="https://s2.loli.net/2023/09/24/XDiIQKB4bFhwyEJ.png" alt="flag数组的内容.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Result.equals(Flag)) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;You Are Right!MD5!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;You Are Wrong! please try it again!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码的作用是判断 Result 数组是否与 Flag 数组相同。关键方法是equals()。*(与上一段 if 语句相比，这句更重要。因为上一段 if 语句要求 包含flag，这一段 if 语句要求 等于flag)*</p><blockquote><p><strong>总结</strong></p><p>此段代码的正向操作是先偏移值为3的凯撒加密，再进行移位</p><p>故反向操作应该是先进行移位，再偏移值为3的凯撒加密</p><p>具体步骤如下：</p><ol><li>将<code>String name = &quot;$gourZroohK&quot;;</code>的<code>name</code>变量的值，即<code>$gourZroohK</code>，进行移位，可得<code>KhourZroog$</code></li><li>对<code>KhourZroog$</code>进行偏移值为3的凯撒解密，可得<code>HelloWorld!</code></li><li>将<code>HelloWorld!</code>进行 MD5 计算后可得flag</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-大白</title>
      <link href="/2023/09/24/CTF-Misc-%E5%A4%A7%E7%99%BD/"/>
      <url>/2023/09/24/CTF-Misc-%E5%A4%A7%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-大白"><a href="#CTF-Misc-大白" class="headerlink" title="CTF-Misc-大白"></a>CTF-Misc-大白</h1><p>原题链接：<a href="https://buuoj.cn/challenges#%E5%A4%A7%E7%99%BD">https://buuoj.cn/challenges#%E5%A4%A7%E7%99%BD</a></p><p>笔者拿到该题，仍是先使用 binwalk 提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e dabai.png --run-as=root</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/14/Gn1qMBEasxtXjcR.png" alt="大白_1.png"></p><p>得到如下文件</p><p><img src="https://s2.loli.net/2023/09/14/CAhWSJHG15MzBNg.png" alt="大白_2.png"></p><p>由图可知，文件 5B 的大小是 0B，为空文件；文件 5B.zlib 的大小是 146.9KB，大于1KB，不为空文件</p><p>尝试使用 python 的 zlib 包解压时报错<code>zlib.error: Error -3 while decompressing data: incorrect data check</code>，使用十六进制编辑器打开 5B.zlib 文件，可见 5B.zlib 文件的文件头（魔术头）为78 5E</p><p><img src="https://s2.loli.net/2023/09/14/XI8NjmSZoPgwMzT.png" alt="大白_4.png"></p><p>查询网络可知 zlib 文件的文件头根据加密方式的不同分为如下3种：</p><p><img src="https://s2.loli.net/2023/09/14/8oDEbMhQaBmVRkN.png" alt="大白_3.png"></p><p>笔者无法解压该 5B.zlib 文件</p><p>随后许久，笔者才注意到原图不能被“爱奇艺万能看图王”打开，能被 win10 的“照片”，在 Linux 中打开原图 大白.png 可见具体报错————<strong>IHDR：CRC error</strong></p><p><img src="https://s2.loli.net/2023/09/14/kLA1RCD9ucjpHel.png" alt="大白_5.png"></p><p>查询网络可知 PNG 文件结构如下：</p><p><img src="https://s2.loli.net/2023/09/14/b2YS8LgyVJTptiv.png" alt="大白_6.png"></p><p>查询网络可知 PNG 数据块结构如下：</p><p><img src="https://s2.loli.net/2023/09/14/3NmoPW4cGJsUVd8.png" alt="大白_7.png"></p><p>png 图片可以使用 TweakPng 快速检查文件</p><p>使用 TweakPng 打开被修改尺寸或者是其他信息的PNG图片时，会有提示。</p><p><img src="https://s2.loli.net/2023/09/14/oWwPGqN9ibSTZVU.png" alt="大白_8.png"></p><p>如上图所示，提示CRC错误。</p><p>存在两种可能：</p><ol><li>图片CRC被修改：尝试用十六进制编辑器修改CRC</li><li>图片尺寸被修改：尝试用十六进制编辑器修改图片尺寸</li></ol><p>笔者首先尝试了第一种可能，即修改CRC，没有得到flag</p><p>笔者其后准备计算图片的正确尺寸，下面附上爆破 png 图片正确尺寸的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">crcbp = <span class="built_in">open</span>(<span class="string">&quot;xxx.png&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()    <span class="comment">#打开图片</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">        data = crcbp[<span class="number">12</span>:<span class="number">16</span>] + \</span><br><span class="line">            struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i)+struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, j)+crcbp[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">        crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc32 == <span class="number">0xffffffff</span>:    <span class="comment">#图片当前CRC</span></span><br><span class="line">            <span class="built_in">print</span>(i, j)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;hex:&#x27;</span>, <span class="built_in">hex</span>(i), <span class="built_in">hex</span>(j))</span><br></pre></td></tr></table></figure><p>以下是本题实际使用的代码，需要注意的是在Python中，在字符串前面加上r的原因是为了处理文件路径中的反斜杠。通常在Windows系统中，文件路径的反斜杠会被解释为转义字符，这可能导致路径错误或无法识别。为了避免这个问题，可以使用<strong>双反斜杠</strong>或者<strong>使用原始字符串（在字符串前面加上r）</strong>来表示路径。原始字符串会保留字符串中的所有字符，不进行转义，从而确保文件路径的准确性。</p><p><img src="https://s2.loli.net/2023/09/15/7C8zgLuUhTOHVpa.png" alt="大白_9.png"></p><p>爆破结果如下</p><p><img src="https://s2.loli.net/2023/09/15/Q7uLbEetvwqzliW.png" alt="大白_10.png"></p><p>这里可以选择不求甚解地直接在十六进制编辑器里搜索<code>02 A7</code>，然后将其后的数据修改为<code>01 df</code>。笔者选择记录 PNG 文件头格式以便日后的学习</p><p><img src="https://s2.loli.net/2023/09/16/uOYETjC54HpnSFx.png" alt="大白_11.png"></p><p>第一个红框内的<code>89 50 4E 47 0D 0A 1A 0A</code>是 PNG 头部 署名域</p><p>第二个红框内的<code>00 00 00 0D</code>是 Length，即 IHDR 数据域的长度（具体原因可见本文第七张图）</p><p>第三个红框内的<code>49 48 44 52</code>是 Chunk Type Code，即数据域类型是IHDR</p><p>其后就是 Chunk Data</p><p>第四个红框内的<code>00 00 02 A7</code>是 Width</p><p>第五个红框内的<code>00 00 01 00</code>是 Height</p><p>参考链接：<a href="https://blog.csdn.net/u013943420/article/details/76855416" title="PNG文件头格式解析">https://blog.csdn.net/u013943420/article/details/76855416</a></p><p><strong>结论： PNG 文件第17个字节至第24个字节是 PNG 的宽和高</strong></p><p>修改后点击另存为，再次打开可见flag</p><p><img src="https://s2.loli.net/2023/09/16/yzvgRLnGx7KflPo.png" alt="dabai.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-九连环</title>
      <link href="/2023/09/23/CTF-Misc-%E4%B9%9D%E8%BF%9E%E7%8E%AF/"/>
      <url>/2023/09/23/CTF-Misc-%E4%B9%9D%E8%BF%9E%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-九连环"><a href="#CTF-Misc-九连环" class="headerlink" title="CTF-Misc-九连环"></a>CTF-Misc-九连环</h1><p>原题链接：<a href="https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF" title="九连环">https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF</a></p><p>笔者拿到该题，先使用 <strong>Stegsolve</strong> ，没有发现信息；再使用十六进制编辑器，可以发现 zip 文件头（<code>50 4B 03 04</code>和<code>PK</code>），证明其隐写了 zip 文件。</p><p>使用 binwalk 提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e 123456cry.jpg --run-as=root</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/16/59PN4x3YIsSicoy.png" alt="九连环_1.png"></p><p>提取得到一个 zip 压缩包，使用压缩软件打开可见2个文件，且<code>good-已合并.jpg</code>从文件名上判断必然包含隐藏信息</p><p><img src="https://s2.loli.net/2023/09/16/B2pJ5ZW8f6gqVsD.png" alt="九连环_2.png"></p><p>直接解压会报错</p><p><img src="https://s2.loli.net/2023/09/17/OzcmkqxuH2L3CwN.png" alt="九连环_3.png"></p><p>根据提示，笔者原以为需要修复 jpg 文件，但是想到压缩的本质是<strong>找出文件中字符串的概率分布，然后将出现概率高的字符串替换成更短的形式</strong>，所以想到应该是 zip 伪加密</p><p>目前为止，解题思路为最终的 flag 在 <code>qwe.zip</code> 压缩包内，并且 qwe.zip 压缩包是真加密，密码隐藏在 <code>good-已合并.jpg</code> 内，但<code>good-已合并.jpg</code>被伪加密了（判断依据：只有 qwe.zip 压缩包是真加密，其他位置的全局方式位标志都应为不加密）</p><p><img src="https://s2.loli.net/2023/09/19/36AXpcPNtE9jJOy.png" alt="九连环_4.png"></p><p>如上图所示，大红框指向的 qwe.zip 压缩包是真加密，good-已合并.jpg是伪加密</p><p>笔者这里直接给出具体的操作方法，关于 zip 伪加密可以参考我的个人博客的这篇文章<a href="https://waltyoung.github.io/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/" title="CTF-Misc-zip伪加密">https://waltyoung.github.io/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/</a></p><p>结合本文第四张图和第五张图，将红框处的<code>01</code>修改为<code>00</code>后另存为</p><p><img src="https://s2.loli.net/2023/09/19/2G5fsw6LdjIDtvr.png" alt="九连环_5.png"></p><p>关于 CTF压缩包 的分析，请参考这篇文章<a href="https://blog.csdn.net/qq_42551635/article/details/116792548" title="关于CTF压缩包的那些事">https://blog.csdn.net/qq_42551635&#x2F;article&#x2F;details&#x2F;116792548</a></p><p>再次解压后可得到图片<code>good-已合并.jpg</code>，使用 <strong>Stegsolve</strong> ，没有发现信息</p><p>笔者查阅网络后得知本题使用了 <strong>Steghide</strong></p><p>Steghide 下载地址：<a href="https://steghide.sourceforge.net/index.php" title="Steghide">https://steghide.sourceforge.net/index.php</a></p><p>使用方法是一般Windows环境变量的配置</p><blockquote><p><strong>Steghide</strong>的命令如下：</p><p>查看图片中嵌入的文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide info 图片名.jpg</span><br></pre></td></tr></table></figure><p>隐藏文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide embed -cf (需要将密码放入的文件) -ef (需要加密的文件)</span><br></pre></td></tr></table></figure><p>提取隐藏的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf 图片名 （-p 密码）</span><br></pre></td></tr></table></figure></blockquote><p>使用命令<code>steghide extract -sf good-已合并.jpg</code>提取文件，需要注意的是本题没有在此设定密码，但不保证之后的题目同样不设密码</p><p><img src="https://s2.loli.net/2023/09/17/hNKIBEzmDRQ2pPl.png" alt="九连环_6.png"></p><p>由上图可见，隐藏文件保存到了 ko.txt，打开后得到真加密压缩包的密码，解压即可得到flag</p><p><img src="https://s2.loli.net/2023/09/17/xo1haRuSI2BmdjG.png" alt="九连环_7.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim优化指南</title>
      <link href="/2023/09/22/Vim%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
      <url>/2023/09/22/Vim%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vim优化指南"><a href="#Vim优化指南" class="headerlink" title="Vim优化指南"></a>Vim优化指南</h1><p>Vim 作为 Linux 中常用编辑器，使用者可根据自己的需要配置 Vim 的工作环境。</p><p>配置方法如下：</p><ol><li>在末行模式下使用命令<code>:set 配置项</code>或<code>set 配置项 = 值</code>或<code>配置项</code>进行配置。该配置方法的特点是 Vim 重启后丢失原有的末行模式下的配置</li><li>修改 Vim 配置文件<code>/etc/vim/vimrc</code>的内容。<strong>需要注意的是双引号是注释符</strong>。该配置方法的特点是对所有用户生效</li><li>修改 用户home 目录下的配置文件<code>~/.vimrc</code>的内容。<code>~</code>是指 用户home 目录。该配置方法的特点是仅对当前用户生效</li></ol><p>在正式开始之前，请先备份 .vimrc 或 vimrc 文件。命令：<code>cp vimrc vimrc.bak</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">syntax enable</span><br><span class="line">syntax on</span><br><span class="line">filetype indent on</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">set backspace=2</span><br><span class="line">set cindent shiftwidth=4</span><br><span class="line">set smartindent</span><br><span class="line">set number</span><br><span class="line">set showmatch</span><br><span class="line">set matchtime=5</span><br><span class="line">set background=dark</span><br><span class="line">set mouse=a</span><br><span class="line">set ruler</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">set nowrapscan</span><br><span class="line">set cursorline</span><br><span class="line">set history=1000</span><br><span class="line">set ignorecase</span><br><span class="line">inoremap( ()&lt;LEFT&gt;</span><br><span class="line">inoremap[ []&lt;LEFT&gt;</span><br><span class="line">inoremap&#123; &#123;&lt;CR&gt;&#125;&lt;UP&gt;</span><br><span class="line">inoremap&lt; &lt;&gt;&lt;LEFT&gt;</span><br><span class="line">inoremap&quot; &quot;&quot;&lt;LEFT&gt;</span><br><span class="line">inoremap&#x27; &#x27;&#x27;&lt;LEFT&gt;</span><br><span class="line">set wrap</span><br><span class="line">set laststatus=2</span><br><span class="line">set cmdheight=1</span><br><span class="line">set shm+=I</span><br></pre></td></tr></table></figure><p><strong>以下是对Vim配置项的解释</strong>：</p><ul><li><code>set nocompatible</code>: 禁用vi兼容模式，启用vim自身的特性。</li><li><code>syntax enable</code>: 启用语法高亮。</li><li><code>syntax on</code>: 启用语法高亮。</li><li><code>filetype indent on</code>: 根据文件类型启用自动缩进。</li><li><code>set tabstop=4</code>: 设置制表符的宽度为4个空格。</li><li><code>set shiftwidth=4</code>: 设置每次缩进或反缩进的宽度为4个空格。</li><li><code>set autoindent</code>: 启用自动缩进。</li><li><code>set cindent</code>: 启用C语言风格的自动缩进。</li><li><code>set backspace=2</code>: 允许在插入模式下删除任何字符，包括换行符和缩进。</li><li><code>set smartindent</code>: 启用智能缩进，根据上一行的缩进进行自动缩进。</li><li><code>set number</code>: 显示行号。</li><li><code>set showmatch</code>: 在输入括号时，高亮显示匹配的括号。</li><li><code>set matchtime=5</code>: 设置括号匹配高亮的时间（单位为十分之一秒）。</li><li><code>set background=dark</code>: 设置背景为暗色，适用于黑色背景的终端。</li><li><code>set mouse=a</code>: 启用鼠标支持。</li><li><code>set ruler</code>: 显示光标位置的行号和列号。</li><li><code>set hlsearch</code>: 高亮显示搜索结果。</li><li><code>set incsearch</code>: 在输入搜索模式时，实时显示匹配的结果。</li><li><code>set nowrapscan</code>: 禁止搜索到文件末尾后自动回到开头。</li><li><code>set cursorline</code>: 高亮显示当前行。</li><li><code>set history=1000</code>: 设置命令历史记录的最大数量为1000。</li><li><code>set ignorecase</code>: 在搜索时忽略大小写。</li><li><code>inoremap( ()&lt;LEFT&gt;</code>: 在插入模式下，将输入的”(“转换为”()”并将光标移动到左括号内。</li><li><code>inoremap[ []&lt;LEFT&gt;</code>: 在插入模式下，将输入的”[“转换为”[]”并将光标移动到左括号内。</li><li><code>inoremap&#123; &#123;&lt;CR&gt;&#125;&lt;UP&gt;</code>: 在插入模式下，将输入的”{“转换为”{}”并将光标移动到上一行。</li><li><code>inoremap&lt; &lt;&gt;&lt;LEFT&gt;</code>: 在插入模式下，将输入的”&lt;”转换为”&lt;&gt;”并将光标移动到左括号内。</li><li><code>inoremap&quot; &quot;&quot;&lt;LEFT&gt;</code>: 在插入模式下，将输入的引号转换为一对引号并将光标移动到引号内。</li><li><code>inoremap&#39; &#39;&#39;&lt;LEFT&gt;</code>: 在插入模式下，将输入的单引号转换为一对单引号并将光标移动到单引号内。</li><li><code>set wrap</code>: 自动换行显示长行。</li><li><code>set laststatus=2</code>: 在状态栏始终显示状态行。</li><li><code>set cmdheight=1</code>: 设置命令行的高度为1行。</li><li><code>set shm+=I</code>: 将当前行的行号显示在状态栏上。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64隐写</title>
      <link href="/2023/09/21/Base64%E9%9A%90%E5%86%99/"/>
      <url>/2023/09/21/Base64%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Base64隐写"><a href="#Base64隐写" class="headerlink" title="Base64隐写"></a>Base64隐写</h1><p>原题链接：<a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99" title="Base64隐写">https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99</a></p><p>Base64 很常见，在 ctf 比赛中更是常见。笔者在遇到本题之前，只将其当做一种加密方式，现在对其做更深入的理解。</p><h2 id="Base64-介绍"><a href="#Base64-介绍" class="headerlink" title="Base64 介绍"></a>Base64 介绍</h2><p>在计算机中的字节共有256个组合，对应就是ascii码，而ascii码的128～255之间的值是不可见字符。而在网络上交换数据时，由于不同的设备对字符的处理方式有区别，不可见字符有可能被错误处理，所以就在传输之前将数据进行Base64编码，以可见字符进行传输。</p><p>Base64 是一种基于 64 个可打印字符（<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>，特殊的 <code>=</code> 作为补零时的后缀）来表示二进制数据的表示方法。因为 2 ^ 6 &#x3D; 64，所以每 6 个 bit 为一个单元，对应某个可打印字符。3 个字节有 24 个 bit ，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。</p><p>下图是 64 个字符的对应表</p><p><img src="https://s2.loli.net/2023/09/21/IxbEOmhs2fAY415.png" alt="base64.png"></p><h2 id="Base64-转换"><a href="#Base64-转换" class="headerlink" title="Base64 转换"></a>Base64 转换</h2><p>以 <code>Man</code> 作为例子，将字符的 ASCII 码换成二进制，从高位取 6 个 bit ，再转化成十进制， 结合表格，就能够得出对应的字符。</p><p><img src="https://s2.loli.net/2023/09/21/nAcfQuFikXBsbHW.png" alt="base64_convert.png"></p><p>如果编码的字节数不能被 3 整除的话，如下图所示，后面就会多出一个或两个字节，这种情况下就用 0 填充缺省的字节，使其能够被 3 整除，再像上面一样进行 Base64 转换，并在编码后的 Base64 文本后加上一个或两个 <code>=</code> ，代表填补的字节数。</p><p><img src="https://s2.loli.net/2023/09/21/CMJLw3Hh5orODbt.png" alt="base64_patch.png"></p><h2 id="Base64-在-URL-中的使用"><a href="#Base64-在-URL-中的使用" class="headerlink" title="Base64 在 URL 中的使用"></a>Base64 在 URL 中的使用</h2><p>由于标准 Base64 编码过后的数据会出现 <code>/</code> 和 <code>+</code> ，在 URL 中是由特殊含义的，浏览器会将他们变为形如 <code>%xx</code> 的格式，这些 % 存入数据库时还要进行转换，因此 URL 改进的 Base64 就用 <code>-</code> 和 <code>_</code> 取代了这两个字符，并且不会在末尾填充 <code>=</code> 号</p><h2 id="Base64-隐写"><a href="#Base64-隐写" class="headerlink" title="Base64 隐写"></a>Base64 隐写</h2><p>Base64 隐写就是利用解码时丢掉的数据进行信息隐藏，仍以下图为例子</p><p><img src="https://s2.loli.net/2023/09/21/CMJLw3Hh5orODbt.png" alt="base64_patch.png"></p><p>因为上图加粗的零是编码时加上的，所以修改这些零对解码数据没有影响，但是 <code>=</code> 那里的零不能拿来修改，否则破坏了解码第一步，加粗的零作为最后一个字符的二进制组成部分，将被删除，不会影响还原。但是最后一个字符会发生变化。<strong>以上图为例， QkM&#x3D; ，QkN&#x3D; ，QkO&#x3D; ，QkP&#x3D; 最终都会还原成 BC 。</strong></p><blockquote><p>一个 Base64 编码的字符串最多有两个 <code>=</code>，1个 <code>=</code> 可以隐写2个 bit ，2个 <code>=</code> 可以隐写4个 bit 。</p></blockquote><p>因为隐藏的信息有限，所以一般会给多行 base64 编码的字符串，每一行隐藏一部分，最终将这些信息拼接起来将得到隐写信息。</p><h2 id="Base64-隐写解密脚本"><a href="#Base64-隐写解密脚本" class="headerlink" title="Base64 隐写解密脚本"></a>Base64 隐写解密脚本</h2><p>笔者发现网络流传的脚本不能直接使用，遂对其进行了修改，并以注释注明，使其能够在Windows下运行。<em>（脚本的作者大概率是Mac用户）</em></p><p>环境：Win10+Python3.9</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Xiao&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">base64chars = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="built_in">str</span>(line, <span class="string">&#x27;utf-8&#x27;</span>).strip(<span class="string">&#x27;\r\n&#x27;</span>) <span class="comment"># Win下使用\r\n，Linux下使用\n</span></span><br><span class="line">        rowb64 = <span class="built_in">str</span>(base64.b64encode(base64.b64decode(stegb64)), <span class="string">&#x27;utf-8&#x27;</span>).strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        offset = <span class="built_in">abs</span>(base64chars.index(stegb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]) - base64chars.index(rowb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">        res = [<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(res)) </span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p><code>base64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;</code>相当于字典</p><p><code>with open(&#39;tmp.txt&#39;, &#39;rb&#39;) as f:</code>是python提供的打开文件的方法，不需要关闭文件，即不需要写 f.close()。</p><ul><li>“r” - 读取 - 默认值。打开文件进行读取，如果文件不存在则报错。</li><li>“b” - 二进制 - 二进制模式（例如图像）。</li></ul><p><code>for line in f.readlines():</code>readlines() 方法返回所有行，遍历每一行</p><p><code>bin_str = &#39;&#39;</code>存储隐藏的flag</p><p><code>stegb64 = str(line, &#39;utf-8&#39;).strip(&#39;\r\n&#39;)</code>删除行末的换行符，strip()方法删除开头或结尾的字符，不能删除中间部分的字符。<strong>需要注意的是Win下使用\r\n，Linux下使用\n</strong></p><p><code>rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), &#39;utf-8&#39;).strip(&#39;\n&#39;)</code>解码得到真实信息后再次编码，并删除行末的换行符</p><p><code>offset = abs(base64chars.index(stegb64.replace(&#39;=&#39;, &#39;&#39;)[-1]) - base64chars.index(rowb64.replace(&#39;=&#39;, &#39;&#39;)[-1]))</code>计算偏离值，<code>replace(&#39;=&#39;,&#39;&#39;)[-1]</code>删除 <code>=</code> 并且返回最后一个字符；index() 方法返回字符在 base64chars 中的位置；abs() 返回2个偏离值相减的绝对值</p><p><code>equalnum = stegb64.count(&#39;=&#39;)</code>计算 <code>=</code> 的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> equalnum:</span><br><span class="line">    bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>如果等号的数量不为0表示隐藏了数据，将隐藏的数据转换成二进制以追加的方式存储到 bin_str 中。bin()方法返回一个整数 int 或者长整数 long int 的二进制表示。zfill()方法返回指定长度的字符串,原字符串右对齐,前面填充0。<em>（笔者还未完全理解）</em></p><p><code>res = [chr(int(bin_str[i:i + 8], 2)) for i in range(0, len(bin_str), 8)]</code><em>（笔者仍未理解）</em></p><p><code>print(&#39;&#39;.join(res))</code>使用字符串的join方法，将列表中的元素用指定的分隔符（这里为空）连接起来，形成一个字符串</p><p>参考链接：<a href="https://www.cnblogs.com/asmurmur/p/14778548.html">https://www.cnblogs.com/asmurmur/p/14778548.html</a></p><h2 id="题目：CTF-Misc-Base64隐写"><a href="#题目：CTF-Misc-Base64隐写" class="headerlink" title="题目：CTF-Misc-Base64隐写"></a>题目：CTF-Misc-Base64隐写</h2><p>原题链接：<a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99" title="Base64隐写">https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]base64%E9%9A%90%E5%86%99</a></p><p>笔者拿到该题，发现是 tar 文件。在 Windows 下直接解压，会出现元数据（meta data）的隐藏文件，导致解压后的文件不能正常打开。故需要在 Linux 下解压，使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x attachment.tar</span><br></pre></td></tr></table></figure><p>解压后的得到的 <code>Comeon!.txt</code> 中包含多行 base64 编码的字符串。笔者当时没有接触到Base64隐写的概念，误将多行 base64 编码的字符串进行了2次 base64 批量解码。最终得到了一串带有乱码的C语言代码。直接将解码结果以十六进制展示仍没有解决乱码问题。查询网络后得知Base64隐写的概念，遂有了本文</p><p>使用的脚本如下</p><p><img src="https://s2.loli.net/2023/09/21/l9vKOrbB1yVpuFH.png" alt="base64隐写.png"></p><p>将需要解密的文件复制到工作目录下，重命名为<code>tmp.txt</code>，运行脚本。需要注意的是<strong>需要解密的文件直接使用原文件</strong></p><p><img src="https://s2.loli.net/2023/09/21/R841LgTq6iIVwoW.png" alt="base64隐写_2.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-谁赢了比赛</title>
      <link href="/2023/09/20/CTF-Misc-%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B/"/>
      <url>/2023/09/20/CTF-Misc-%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-谁赢了比赛"><a href="#CTF-Misc-谁赢了比赛" class="headerlink" title="CTF-Misc-谁赢了比赛"></a>CTF-Misc-谁赢了比赛</h1><p>原题链接：<a href="https://buuoj.cn/challenges#%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B%EF%BC%9F" title="谁赢了比赛？">https://buuoj.cn/challenges#%E8%B0%81%E8%B5%A2%E4%BA%86%E6%AF%94%E8%B5%9B%EF%BC%9F</a></p><p>笔者拿到该题后，先使用十六进制编辑器确定了图片中存在隐藏文件，使用binwalk <code>binwalk -e who_won_the_game.png --run-as=root</code>提取文件，得到一个 rar 压缩包</p><p><img src="https://s2.loli.net/2023/09/20/7WCXOnBHAEbs2m1.png" alt="谁赢了比赛_1.png"></p><p>由上图可见，压缩包内可见flag.txt 是未被加密的，hehe.gif 是被加密的。flag.txt 中的信息无效</p><p>检查 rar 压缩包的文件头、文件尾</p><p><img src="https://s2.loli.net/2023/09/20/nGvIbRPpEDOFM7s.png" alt="谁赢了比赛_2.png"></p><p>由上图可见，rar 压缩包的文件头（<code>52 61 72 21 1A 07 00</code>）是正常的</p><p><img src="https://s2.loli.net/2023/09/20/zCZtDA8kWOlSqhJ.png" alt="谁赢了比赛_3.png"></p><p>由上图可见，rar 压缩包的文件头（<code>C4 3D 7B 00 40 70 00</code>）是正常的</p><p>在 rar 压缩包的十六进制文本里直接搜索 gif 图片的文件头（<code>47 49 46 38</code>），没有搜索到该文件头，因为<strong>压缩的本质是找出文件中字符串的概率分布，然后将出现概率高的字符串替换成更短的形式</strong>，所以猜测是真加密</p><p>笔者至此没有思路，经网络提醒，还有一种最后的方法——爆破</p><p>优先从4位纯数字开始爆破，幸运地得到了密码</p><p><img src="https://s2.loli.net/2023/09/20/dCXGeYik893FEMI.png" alt="谁赢了比赛_4.png"></p><p>使用密码解压后得到 gif 图片，先使用十六进制编辑器确定了图片中不存在隐藏文件，再置于 Stegsolve ，逐帧检查，在第310帧的时候发现了下图</p><p><img src="https://s2.loli.net/2023/09/20/WKIrXe1Eos4P2V6.png" alt="谁赢了比赛_5.png"></p><p>另存改图为 bmp 文件（<strong>因为bmp 是未经过压缩的图像格式</strong>）</p><p>优先检查有无 LSB隐写，检查结果：无</p><p>但发现 Red 0平面包含了一张二维码，如下图所示</p><p><img src="https://s2.loli.net/2023/09/20/6viJX3BfgmMOKHo.png" alt="谁赢了比赛_6.png"></p><p>直接解码可得flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-来首歌吧</title>
      <link href="/2023/09/19/CTF-Misc-%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7/"/>
      <url>/2023/09/19/CTF-Misc-%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-来首歌吧"><a href="#CTF-Misc-来首歌吧" class="headerlink" title="CTF-Misc-来首歌吧"></a>CTF-Misc-来首歌吧</h1><p>原题链接：<a href="https://buuoj.cn/challenges#%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7" title="来首歌吧">https://buuoj.cn/challenges#%E6%9D%A5%E9%A6%96%E6%AD%8C%E5%90%A7</a></p><p>将 wav 文件置入 <strong>Audicity</strong> ，可观察到左声道特殊</p><p><img src="https://s2.loli.net/2023/09/16/StmTIuXNWnqY1Kb.png" alt="来首歌吧_1.png"></p><p>放大后可见摩斯电码</p><p><img src="https://s2.loli.net/2023/09/16/Lw9KqIu1EvOY26g.png" alt="来首歌吧_2.png"></p><p>逐个对照下表的摩斯电码，可以得到flag</p><p><img src="https://s2.loli.net/2023/09/16/h9J58BbN6DPxMIk.jpg" alt="摩斯电码.jpg"></p><hr><p>本文重点在于介绍另一款音频隐写与提取工具————<strong>MP3Stego</strong></p><p>MP3Stego下载地址：<a href="https://www.petitcolas.net/fabien/software/" title="MP3Stego">https://www.petitcolas.net/fabien/software/</a></p><p>MP3Stego 提供图形化用户界面（即GUI）但为方便日后学习，笔者仍介绍在命令行下的使用方法</p><p>加密命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encode -E data.txt -P pass sound.wav sound.mp3</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li>data.txt:需要加密的txt文件</li><li>pass:密码</li><li>sound.wav:需要将密码放入的wav文件)</li><li>sound.mp3:需要解密的文件</li></ul><p>解密命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Decode -X -P pass sound.mp3</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li>pass:密码</li><li>sound.mp3:需要解密的文件</li></ul><p><strong>需要注意的是 MP3Stego 只能分析、处理 MP3 文件</strong>（这也是本题使用不到 MP3Stego 的原因，即使本题的 wav 文件的文件名在诱导我们）</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-LSB隐写</title>
      <link href="/2023/09/18/CTF-Misc-LSB%E9%9A%90%E5%86%99/"/>
      <url>/2023/09/18/CTF-Misc-LSB%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-LSB隐写"><a href="#CTF-Misc-LSB隐写" class="headerlink" title="CTF-Misc-LSB隐写"></a>CTF-Misc-LSB隐写</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>MSB（Most Significant Bit）：最高有效位，二进制中代表最高值的比特位，这一位对数值的影响最大</p><p>LSB（Least Significant Bit）：最低有效位，二进制中代表最低值的比特位</p><p>例如，在二进制的1001（十进制的9）中，最左边的“1”即是MSB，最右边的“1”是LSB</p><p>常见CPU采用小端模式（Little-Endian）网络字节顺序采用大端模式（big endian）排序方式，TCP&#x2F;IP协议规定:接收到的第一个字节视作高位字节，这就要求发送端发送的第一个字节是高位字节。<strong>intel x86的CPU使用的是LE（Windows中称为“主机字节序”）,而SocksAddr中使用的则是BE（就是“网络字节序”），所以在使用网络编程时需要使用htns,htnl,nths,nthl来倒字节序</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>图片中的图像像素一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，即有256种颜色。LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>隐写的内容不同，主要分为2种：字符和文件</p><p>原题链接：<a href="https://buuoj.cn/challenges#%E9%95%9C%E5%AD%90%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%96%E7%95%8C" title="镜子里面的世界">https://buuoj.cn/challenges#%E9%95%9C%E5%AD%90%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%96%E7%95%8C</a></p><p>工具： <strong>Stegsolve</strong> </p><p>如下图所示，可见隐写的内容是字符，即flag</p><p><img src="https://s2.loli.net/2023/09/15/LjCUHefJPuD6AgX.png" alt="镜子里面的世界_1.png"></p><hr><p>原题链接：<a href="https://buuoj.cn/challenges#LSB" title="LSB">https://buuoj.cn/challenges#LSB</a></p><p>如下图所示，可见隐写的内容是 png 图片</p><p><img src="https://s2.loli.net/2023/09/15/Ah1C8QGxUsXadqH.png" alt="LSB_1.png"></p><p>将得到的 png 图片（即二维码）解码，解码平台————草料二维码解码器：<a href="https://cli.im/deqr/other" title="草料二维码解码器">https://cli.im/deqr/other</a></p><hr><p>原题链接：<a href="https://buuoj.cn/challenges#FLAG" title="FLAG">https://buuoj.cn/challenges#FLAG</a></p><p>如下图所示，可见隐写的内容是 zip 压缩包（<code>50 4b 03 04</code>和<code>PK</code>的文件头，应及时反应是 zip 压缩包）</p><p><img src="https://s2.loli.net/2023/09/15/z1BGXYsxC2T6r5e.png" alt="FLAG_1.png"></p><p><strong>需要注意的是 0平面 可能隐写内容，1平面 也可能隐写内容</strong></p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/461716971" title="浅谈LSB隐写解题与出题">https://zhuanlan.zhihu.com/p/461716971</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-N种方法解决</title>
      <link href="/2023/09/17/CTF-Misc-N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/09/17/CTF-Misc-N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-N种方法解决"><a href="#CTF-Misc-N种方法解决" class="headerlink" title="CTF-Misc-N种方法解决"></a>CTF-Misc-N种方法解决</h1><p>原题链接：<a href="https://buuoj.cn/challenges#N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3" title="N种方法解决">https://buuoj.cn/challenges#N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3</a></p><p>本题如题名有N种方法解决</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>使用十六进制编辑器打开文件，可见 base64 编码的字符</p><p><img src="https://s2.loli.net/2023/09/16/9BgidRnlHkDTJ4C.png" alt="N种方法解决_1.1.png"></p><p>文件尾也符合 base64 编码的特征，故将其间一整段字符使用 base64 解码。</p><p><img src="https://s2.loli.net/2023/09/16/6XtxJCQELD2fngq.png" alt="N种方法解决_1.2.png"></p><p><strong>需要注意的是 base64 解码的结果必须直接以十六进制展示，不能将 base64 解码得到的乱码复制到十六进制编辑器再计算其十六进制（后者的操作将导致数据不完整）</strong></p><p>下图是正确解码的结果</p><p><img src="https://s2.loli.net/2023/09/16/7nK514ty3eaOHoA.png" alt="N种方法解决_1.3.png"></p><p>复制结果，保存为 png 图片（<code>89 50 4E 47</code>是 PNG 的文件头）</p><p>得到一张二维码，置于草料二维码解码器<a href="https://cli.im/deqr/other" title="草料二维码解码器">https://cli.im/deqr/other</a>解码</p><hr><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>PHP 内置很多 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:<span class="comment">// — 访问本地文件系统</span></span><br><span class="line">http:<span class="comment">// — 访问 HTTP(s) 网址</span></span><br><span class="line">ftp:<span class="comment">// — 访问 FTP(s) URLs</span></span><br><span class="line">php:<span class="comment">// — 访问各个输入/输出流（I/O streams）</span></span><br><span class="line">zlib:<span class="comment">// — 压缩流</span></span><br><span class="line">data:<span class="comment">// — 数据（RFC 2397）</span></span><br><span class="line">glob:<span class="comment">// — 查找匹配的文件路径模式</span></span><br><span class="line">phar:<span class="comment">// — PHP 归档</span></span><br><span class="line">ssh2:<span class="comment">// — Secure Shell 2</span></span><br><span class="line">rar:<span class="comment">// — RAR</span></span><br><span class="line">ogg:<span class="comment">// — 音频流</span></span><br><span class="line">expect:<span class="comment">// — 处理交互式的流</span></span><br></pre></td></tr></table></figure><p>如下图所示，这是 PHP 伪协议的例子</p><p><img src="https://s2.loli.net/2023/09/16/NltSmE5exIipaOn.png" alt="N种方法解决_2.0.png"></p><p>本题中存在类似的 PHP 伪协议</p><p><img src="https://s2.loli.net/2023/09/16/4a2Qw3xUTNrCJz7.png" alt="N种方法解决_2.1.png"></p><p>直接将十六进制的字符复制到浏览器</p><p><img src="https://s2.loli.net/2023/09/16/tvlUh5TbQ93RP4j.png" alt="N种方法解决_2.2.png"></p><p>得到一张二维码，置于草料二维码解码器<a href="https://cli.im/deqr/other" title="草料二维码解码器">https://cli.im/deqr/other</a>解码</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-另外一个世界</title>
      <link href="/2023/09/16/CTF-Misc-%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C/"/>
      <url>/2023/09/16/CTF-Misc-%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-另外一个世界"><a href="#CTF-Misc-另外一个世界" class="headerlink" title="CTF-Misc-另外一个世界"></a>CTF-Misc-另外一个世界</h1><p>原题链接：<a href="https://buuoj.cn/challenges#%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C" title="另外一个世界">https://buuoj.cn/challenges#%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%96%E7%95%8C</a></p><p>笔者在做该题时，首先尝试了 Stegsolve，没有获得有效信息，然后打开了十六进制编辑器，在文件末尾发现了一段可疑的二进制序列。（需要注意的是查看文件的十六进制时，不仅需要关注到文件的头尾，而且在没有思路的时候需要关注到文件的中间部分，可能遗漏信息）</p><p><img src="https://s2.loli.net/2023/09/15/6FMyEBNQfTOglax.png" alt="另外一个世界_1.png"></p><p>笔者没有思路，选择了看 wp (writeup)<em>(笔者太笨了QAQ)</em></p><p>二进制序列以8位为一组，转换为十进制，再对照 ASCII 码表得出字符，最后以flag格式提交</p><p><img src="https://s2.loli.net/2023/09/15/9uqXYGHoKfIBaL2.png" alt="另外一个世界_2.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Misc-zip伪加密</title>
      <link href="/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/09/15/CTF-Misc-zip%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CTF-Misc-zip伪加密"><a href="#CTF-Misc-zip伪加密" class="headerlink" title="CTF-Misc-zip伪加密"></a>CTF-Misc-zip伪加密</h1><p>原题链接：<a href="https://buuoj.cn/challenges#zip%E4%BC%AA%E5%8A%A0%E5%AF%86">https://buuoj.cn/challenges#zip%E4%BC%AA%E5%8A%A0%E5%AF%86</a></p><p>一个 ZIP 文件由三个部分组成：</p><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志</p><p><strong>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包</strong>。</p><p><strong>压缩源文件数据区</strong>：</p><ul><li><strong>50 4B 03 04</strong>：这是头文件标记，十六进制表示为<strong>PK</strong></li><li>14 00：解压文件所需 pkware 版本</li><li><strong>00 00</strong>：全局方式位标记（有无加密）</li><li>08 00：压缩方式</li><li>50 A3：最后修改文件时间</li><li>A5 4A：最后修改文件日期</li><li>21 38 76 64：CRC-32校验（1480B516）</li><li>19 00 00 00：压缩后尺寸（25）</li><li>17 00 00 00：未压缩尺寸（23）</li><li>08 00：文件名长度</li><li>00 00：扩展记录长度</li></ul><p><strong>压缩源文件目录区</strong>:</p><ul><li><strong>50 4B 01 02</strong>：目录中文件文件头标记</li><li>1F 00：压缩使用的 pkware 版本</li><li>14 00：解压文件所需 pkware 版本</li><li><strong>00 00</strong>：全局方式位标记（有无加密）</li><li>08 00：压缩方式</li><li>50 A3：最后修改文件时间</li><li>A5 4A：最后修改文件日期</li><li>21 38 76 65：CRC-32校验（1480B516）</li><li>19 00 00 00：压缩后尺寸（25）</li><li>17 00 00 00：未压缩尺寸（23）</li><li>08 00：文件名长度</li><li>24 00：扩展字段长度</li><li>00 00：文件注释长度</li><li>00 00：磁盘开始号</li><li>00 00：内部文件属性</li><li>20 00 00 00：外部文件属性</li><li>00 00 00 00：局部头部偏移量</li></ul><p><strong>压缩源文件目录结束标志</strong>:</p><ul><li>50 4B 05 06：目录结束标记</li><li>00 00：当前磁盘编号</li><li>00 00：目录区开始磁盘编号</li><li>01 00：本磁盘上纪录总数</li><li>01 00：目录区中纪录总数</li><li>5A 00 00 00：目录区尺寸大小</li><li>3F 00 00 00：目录区对第一张磁盘的偏移量</li><li>00 00 00：ZIP 文件注释长度</li></ul><p>文件数据区的全局方式位标记是文件头之后的第三个字节</p><p>文件目录区的全局方式位标记是文件头之后的第五个字节</p><p><strong>无加密</strong><br>压缩源文件数据区的全局方式位标记应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code></p><p><strong>假加密</strong><br>压缩源文件数据区的全局方式位标记应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>01 00</code></p><p><strong>真加密</strong><br>压缩源文件数据区的全局方式位标记应当为<code>01 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>01 00</code></p><p><strong>全局方式位标记的四个数字中只有第二个数字对其有影响</strong></p><ul><li>第二个数字为奇数时，加密 </li><li>第二个数字为偶数时，未加密</li></ul><p>这是题目的原文件的十六进制</p><p><img src="https://s2.loli.net/2023/09/14/4dOImnfhrQi3cvo.jpg" alt="伪加密_1.jpg"></p><p>对照上文，将<code>09 00</code><em>全部</em>修改为<code>00 00</code>，再次解压可得flag。<em>（此处一定不是真加密，出题人将源文件数据区和目录区的全局方式位标记都修改了）</em></p><p>参考链接：</p><ol><li><a href="https://blog.csdn.net/qq_32350719/article/details/102661596" title="CTF-伪加密">https://blog.csdn.net/qq_32350719&#x2F;article&#x2F;details&#x2F;102661596</a></li><li><a href="https://blog.csdn.net/qq_26187985/article/details/83654197" title="zip伪加密原理及操作">https://blog.csdn.net/qq_26187985&#x2F;article&#x2F;details&#x2F;83654197</a></li></ol><hr><p>笔者最初的笔记参考了伪教程，虽然当时的题目解决了，但是其他题目遇到问题了。鉴于网络的伪教程过多，说法不一致，所以笔者决定自己动手实验一遍</p><p>这是无加密的 zip 文件</p><p><img src="https://s2.loli.net/2023/09/19/GASzYLgfxU4BkJq.png" alt="zip无加密.png"></p><p>这是真加密的 zip 文件</p><p><img src="https://s2.loli.net/2023/09/19/JmacPgFVw4vhE1i.png" alt="zip真加密.png"></p><p>这是修改文件目录区的伪加密的 zip 文件</p><p><img src="https://s2.loli.net/2023/09/19/SVJO83k6BUGbdWT.png" alt="zip伪加密_修改文件目录区.png"></p><p>这是修改文件数据区的伪加密的 zip 文件</p><p><img src="https://s2.loli.net/2023/09/19/18LBjfhv543VkK2.png" alt="zip伪加密_修改文件数据区.png"></p><p>最终结果如下</p><p><img src="https://s2.loli.net/2023/09/19/cwg7yKb6svTDlWS.png" alt="结果.png"></p><p>与网络上的结论不同，只有修改文件数据区的全局方式位标记，才被提示加密了（可能与笔者使用的解压缩软件和 pkware 版本相关）</p><p>但在做题过程中确实遇到的是修改文件目录区，所以需要做更多的题目来验证</p><blockquote><p>目前文件数据区和目录区的全局方式位标记都需要留意</p><p>文件数据区的全局方式位标记是文件头之后的第三个字节</p><p>文件目录区的全局方式位标记是文件头之后的第五个字节</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTFS交换数据流隐藏文件</title>
      <link href="/2023/09/14/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
      <url>/2023/09/14/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="NTFS交换数据流隐藏文件"><a href="#NTFS交换数据流隐藏文件" class="headerlink" title="NTFS交换数据流隐藏文件"></a>NTFS交换数据流隐藏文件</h1><blockquote><p>NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法看到非主文件的数据流。它使用资源派生来维持与文件相关的信息。<strong>在Windows下，文件名带有<code>:</code>的文件被视为NTFS流的非主文流，类似 Linux 的  swp 文件</strong>。</p></blockquote><p>将 123 写入到 NTFS_demo.txt:1.txt 文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 123 &gt; NTFS_demo.txt:1.txt</span><br></pre></td></tr></table></figure><p>此时在文件中可见产生了一个 NTFS_demo.txt 文件，打开 NTFS_demo.txt 文件，可见是空白的</p><p><img src="https://s2.loli.net/2023/09/14/rqV57Fh1QXbJiUc.png" alt="demo.txt.png"></p><p>使用 notepad 命令打开 NTFS_demo.txt:1.txt 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad NTFS_demo.txt:1.txt</span><br></pre></td></tr></table></figure><p>notepad 命令将唤起记事本，可见输入内容“123”</p><p><img src="https://s2.loli.net/2023/09/14/1s9DCnw4vtNpr6U.png" alt="1.txt.png"></p><p>参考链接：<a href="https://www.qingsword.com/qing/812.html" title="利用NTFS交换数据流隐藏文件">https://www.qingsword.com/qing/812.html</a></p><p>如何检测和清除NTFS-ADS隐藏的文件：</p><ol><li>对于压缩包类文件，可以使用压缩软件打开，在压缩软件中查看所需内容；也可以在Linux中直接解压该文件</li><li>合理利用工具，NTFS交换数据流检测工具的下载地址：<a href="https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/tools/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7.rar">https://waltyoung-music-1317864421.cos.ap-shanghai.myqcloud.com/tools/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7.rar</a></li></ol><hr><p>需要注意的是，type命令执行 NTFS_demo.txt 文件和 NTFS_demo.txt:1.txt 文件的结果是不同的</p><p><code>type NTFS_demo.txt</code>命令执行结果为空（因为NTFS_demo.txt文件中没有内容）</p><p><code>type NTFS_demo.txt:1.txt</code>命令执行结果如下所示</p><p><img src="https://s2.loli.net/2023/09/14/A9CjBwLT7Okgq6H.png" alt="type命令执行不同文件.png"></p><p>echo 命令和 type 命令存在显著差异</p><p>echo 命令是将字符写入到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 456 &gt;&gt; NTFS_demo.txt:1.txt</span><br></pre></td></tr></table></figure><p>type 命令是将已存在的文件用交换数据流的方式写到另外一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> 456.txt &gt;&gt; NTFS_demo.txt:1.txt</span><br></pre></td></tr></table></figure><p>注：“&gt;&gt;”是追加重定向符号，与”&gt;”类似，但是会将命令的输出追加到文件的末尾，而不是覆盖文件内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> 隐写 </tag>
            
            <tag> OS </tag>
            
            <tag> Forensics </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次一句话木马的探索</title>
      <link href="/2023/09/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
      <url>/2023/09/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="记一次一句话木马的探索"><a href="#记一次一句话木马的探索" class="headerlink" title="记一次一句话木马的探索"></a>记一次一句话木马的探索</h1><p>笔者在做CTF题时，发现了未曾见过的一句话木马<code>┼攠數畣整爠煥敵瑳∨≡┩愾</code>，就此展开探索</p><p>由网络可知<strong>这是ANSI 转 Unicode编码的 access 木马</strong></p><p>ANSI是一种字符代码，对于不同语言来说，ANSI对应的编码是不同的</p><ul><li>在中文系统中，使用ANSI保存，编码集是 GBK（MS936）</li><li>在日文系统中，使用ANSI保存，编码集是 Shift_JIS（MS932）</li></ul><p>在CMD中可以使用<code>chcp</code>命令查看Windows当前的页面编码集，编码集根据时区选择。页面编码936在Win95及之前表示GB2312，在Win95之后表示GBK，需要注明的是GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。参考链接：<a href="https://blog.csdn.net/sxzlc/article/details/106203495" title="文件编码 ANSI、GBK、GB2312、MS936、MS932、SJIS、Windows-31 、EUC-JP 、EBCDIC 等等之间的区别与联系">https://blog.csdn.net/sxzlc/article/details/106203495</a>这里提供查询页面编码的网址<a href="https://blog.csdn.net/sxzlc/article/details/106270405" title="windows中，页面编码集一览 （chcp code）">https://blog.csdn.net/sxzlc/article/details/106270405</a></p><blockquote><p>UTF-16是一种编码方式，用于将Unicode字符转换为二进制数据。在UTF-16中，每个字符通常占用2个字节。</p><p>由于计算机存储数据的方式有两种：Big Endian（大端存储，高位低地址、低位高地址）和<strong>Little Endian（小端存储，低位低地址、高位高地址）</strong>，因此在使用UTF-16编码时，需要通过在文件开头添加一个特殊字符来指示文件是使用Big Endian还是Little Endian的方式存储数据。这个特殊字符就是BOM（Byte Order Mark），它是一个Unicode字符，其编码为U+FEFF。</p><p><strong>在 Windows 平台下，默认的Unicode编码为UTF-16 Little Endian</strong>，所以在UTF-16编码的文件开头会添加一个BOM字符（U+FEFF），以表示文件是以Little Endian方式存储数据。这个BOM字符在文件中的作用是告诉解码器如何正确地解析文件中的字符数据。</p></blockquote><p>通过将木马复制粘贴到记事本，另存为5种不同编码方式的文件(ANSI、UTF-8、带有BOM的UTF-8、UTF-16 Big Endian、UTF-16 Little Endian)，再使用十六进制查看</p><p><img src="https://s2.loli.net/2023/09/13/b4VIw8pOzBrnJWg.png" alt="UTF-16 Little Endian编码.png"></p><p>由图可见，在UTF-16 Little Endian编码下可见正常的文字——<code>&lt;% execute request(&quot;a&quot;)%&gt;</code></p><p>此处收集常见的一句话木马：</p><ol><li><a href="https://blog.csdn.net/forest_fire/article/details/50944437" title="收集一些常见的webshell后门的特征码">https://blog.csdn.net/forest_fire&#x2F;article&#x2F;details&#x2F;50944437</a></li><li><a href="https://www.cnblogs.com/goodgad/p/13463866.html" title="常见的一句话木马">https://www.cnblogs.com/goodgad/p/13463866.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 记一次XXX </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次开发过程中根据抓包和Request-Id（日志）排错</title>
      <link href="/2023/09/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%8A%93%E5%8C%85%E5%92%8CRequest-Id%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89%E6%8E%92%E9%94%99/"/>
      <url>/2023/09/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%8A%93%E5%8C%85%E5%92%8CRequest-Id%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89%E6%8E%92%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="记一次开发过程中根据抓包和Request-Id（日志）排错"><a href="#记一次开发过程中根据抓包和Request-Id（日志）排错" class="headerlink" title="记一次开发过程中根据抓包和Request-Id（日志）排错"></a>记一次开发过程中根据抓包和Request-Id（日志）排错</h1><p>笔者正在为<a href="https://waltyoung.github.io/movies/">https://waltyoung.github.io/movies/</a>嵌入视频播放器，而后发现他人视频的URL有效，可以正常播放视频，但自己视频的URL无法正常播放视频，就此展开排错。</p><p>首先，笔者花费数个小时排除代码问题</p><p>其次，笔者又花费许久排除URL的问题（即腾讯云上存储的文件访问权限的问题）</p><p>再次，笔者又排除了网络环境问题（笔者确实发现网络环境不健康，但不是主要问题）</p><p>最后，笔者才考虑到抓包重新定位问题（笔者太笨了QAQ）</p><p>笔者的音乐和视频都存储在腾讯云上，但是笔者的音乐播放器正常工作，视频播放器未正常工作，所以对于二者分别抓包再做比较</p><p>笔者分析了抓包结果，发现以下两点：</p><ol><li>返回码不同</li><li>腾讯云的自定义头的字段存在较大区别</li></ol><p>针对第一点（返回码不同），视频播放器的返回码是206，笔者搜索、学习了返回码206代表的含义。HTTP <code>206 Partial Content</code>成功状态响应代码指示请求已成功并且主体包含所请求的数据区间，该数据区间是在请求的 Range 字段指定的。<strong>可以简单地理解为返回码206是请求视频等大资源时的特定的返回码</strong>，因为用户不可能等待视频的完整传输完成，事实情况也是视频边下边播</p><p>针对第二点（腾讯云的自定义头的字段存在较大区别），二者的<code>X-Cos-Request-Id</code>值不同，并且未正常工作的视频播放器多一个<code>X-Cos-Trace-Id</code>字段</p><p><img src="https://s2.loli.net/2023/09/12/BMFcPgZ84LQVvm9.png" alt="X-Cos-Trace-Id.png"></p><p>腾讯云上对于<code>X-Cos-Request-Id</code>和<code>X-Cos-Trace-Id</code>的解释如下</p><p><img src="https://s2.loli.net/2023/09/12/uLjkTCMd5Yb73Z4.png" alt="X-Cos-Request-Id和X-Cos-Trace-Id的解释.png"></p><p>根据解释，笔者想到腾讯云的日志也可以帮助分析问题（笔者没有找到腾讯云对象存储服务的日志，但是找到了自助诊断工具）</p><p><img src="https://s2.loli.net/2023/09/12/lNuHmS31z2pfB5U.png" alt="自助诊断工具.png"></p><p>如图所示，找到跨域访问设置，解决问题</p><p><img src="https://s2.loli.net/2023/09/12/ZFHJwI3SNkdlKX5.png" alt="跨域访问设置.png"></p><blockquote><p><strong>总结</strong>：</p><p>从想到抓包至问题解决，只用了不到一个小时，远低于排除代码、文件权限问题的耗时，所以选择合适合理的方法定位、分析问题非常重要。当然，无关问题的排除也很重要</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 记一次XXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WHERE、CHECK、HAVING的区别</title>
      <link href="/2023/09/07/WHERE%E3%80%81CHECK%E3%80%81HAVING%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/09/07/WHERE%E3%80%81CHECK%E3%80%81HAVING%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="WHERE、CHECK、HAVING的区别"><a href="#WHERE、CHECK、HAVING的区别" class="headerlink" title="WHERE、CHECK、HAVING的区别"></a>WHERE、CHECK、HAVING的区别</h1><p>在T-SQL语言中，WHERE、CHECK、HAVING都是用于筛选数据的关键字，但它们的使用场景和作用略有不同。</p><ol><li>WHERE：WHERE用于在SELECT、UPDATE、DELETE等语句中筛选数据，它是一个过滤器，可以根据指定的条件从表中选择符合条件的记录。WHERE子句可以包含多个条件，多个条件之间可以使用AND或OR进行连接。<strong>WHERE子句不能使用聚合函数</strong>。**常见的聚合函数如下：count()、sum()、avg()、min()、max()**。</li><li>CHECK：CHECK用于在创建表时定义列的约束条件，它可以限制列中的数据必须满足指定的条件。例如，可以使用CHECK约束限制某个列的取值范围、数据类型、长度等。CHECK约束可以在创建表时定义，也可以在ALTER TABLE语句中添加。</li><li>HAVING：HAVING用于在GROUP BY子句中筛选数据，它是一个过滤器，可以根据指定的条件从分组后的结果集中选择符合条件的记录。HAVING子句可以包含多个条件，多个条件之间可以使用AND或OR进行连接。</li></ol><p>总的来说，WHERE用于在SELECT、UPDATE、DELETE等语句中筛选数据，CHECK用于在创建表时定义列的约束条件；HAVING用于在GROUP BY子句中筛选数据，HAVING必须写在GROUP BY之后，例<code>GROUP BY kind HAVING num &gt; 3</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WHERE子句可后接的关键字</title>
      <link href="/2023/09/06/WHERE%E5%AD%90%E5%8F%A5%E5%8F%AF%E5%90%8E%E6%8E%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/09/06/WHERE%E5%AD%90%E5%8F%A5%E5%8F%AF%E5%90%8E%E6%8E%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>WHERE子句可以后接以下关键字</strong>：</p><ol><li>AND：用于连接多个条件，要求同时满足所有条件。</li><li>OR：用于连接多个条件，只要满足其中一个条件即可。</li><li>NOT：用于否定一个条件。</li><li>IN：用于指定一个范围，判断某个值是否在这个范围内。</li><li>BETWEEN：用于指定一个范围，判断某个值是否在这个范围内。</li><li>LIKE：用于模糊匹配，判断某个值是否符合指定的模式。</li><li>IS NULL：用于判断某个值是否为空。</li><li>EXISTS：用于判断子查询是否返回结果。</li><li>ANY&#x2F;SOME：用于判断某个值是否与子查询中的任意一个值相等。</li><li>ALL：用于判断某个值是否与子查询中的所有值都相等。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LEFT JOIN与JOIN的区别</title>
      <link href="/2023/09/05/LEFT-JOIN%E4%B8%8EJOIN%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/09/05/LEFT-JOIN%E4%B8%8EJOIN%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="LEFT-JOIN与JOIN的区别"><a href="#LEFT-JOIN与JOIN的区别" class="headerlink" title="LEFT JOIN与JOIN的区别"></a>LEFT JOIN与JOIN的区别</h1><p>在SQL中，JOIN是连接两个或多个表的操作，而LEFT JOIN是其中一种JOIN的类型。</p><p>JOIN操作会返回两个表中匹配的行，如果两个表中没有匹配的行，则不会返回任何结果。而LEFT JOIN操作会返回左表中的所有行，即使在右表中没有匹配的行，左表中的行也会被返回，右表中没有匹配的列则会用NULL填充。</p><p>举个例子，假设有两个表A和B，A表中有3行数据，B表中有2行数据，其中一行数据的ID与A表中的一行数据的ID相同，另一行数据的ID与A表中的任何一行数据的ID都不相同。使用JOIN操作，只会返回一行数据，即A表中ID与B表中ID相同的那行数据。而使用LEFT JOIN操作，则会返回A表中的所有3行数据，其中一行数据与B表中的那行数据匹配，另外两行数据的B表中的列则会用NULL填充。</p><p>因此，LEFT JOIN操作可以保证左表中的所有数据都会被返回，即使在右表中没有匹配的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKCS5padding和PKCS7padding的区别</title>
      <link href="/2023/09/04/PKCS5padding%E5%92%8CPKCS7padding%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/09/04/PKCS5padding%E5%92%8CPKCS7padding%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="PKCS5padding和PKCS7padding的区别"><a href="#PKCS5padding和PKCS7padding的区别" class="headerlink" title="PKCS5padding和PKCS7padding的区别"></a>PKCS5padding和PKCS7padding的区别</h1><p>PKCS5padding和PKCS7padding（PKCS7padding是PKCS#7填充的简称，PKCS#7是密码学标准PKCS（Public Key Cryptography Standards）中定义的填充方案，用于在加密算法中对数据进行填充。）是两种常见的填充方案，用于在加密前将数据块的大小调整为加密算法所要求的固定大小。它们在填充字节的值和填充方式上有一些区别。</p><p><strong>PKCS5padding</strong>：</p><ul><li>填充字节的值等于需要填充的字节数。</li><li>如果需要填充的字节数为n，则填充n个字节，每个字节的值为n。</li><li>例如，如果需要填充2个字节，那么填充的字节为0x02 0x02。</li></ul><p><strong>PKCS7padding</strong>：</p><ul><li>填充字节的值等于需要填充的字节数。</li><li>如果需要填充的字节数为n，则填充n个字节，每个字节的值为n。</li><li>与PKCS5padding的区别在于，PKCS7padding可以用于任意块大小的加密算法，而不仅限于PKCS5padding的8字节块大小。</li><li>例如，如果需要填充2个字节，那么填充的字节为0x02 0x02。</li></ul><p>总结：PKCS5padding和PKCS7padding在填充字节的值和填充方式上略有不同，但<strong>在实际应用中，它们通常可以互相替换使用</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEFI和BIOS的区别</title>
      <link href="/2023/09/03/UEFI%E5%92%8CBIOS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/09/03/UEFI%E5%92%8CBIOS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="UEFI和BIOS的区别"><a href="#UEFI和BIOS的区别" class="headerlink" title="UEFI和BIOS的区别"></a>UEFI和BIOS的区别</h1><p>UEFI（统一的可扩展固件接口）和BIOS（基本输入&#x2F;输出系统）都是计算机的固件接口，用于启动和管理计算机的硬件和软件。</p><p>BIOS是一种旧的固件接口，它是在计算机启动时首先加载的。它负责初始化和检测计算机的硬件设备，例如处理器、内存、硬盘等，并将控制权交给操作系统。BIOS还包含一个小型的操作系统，称为CMOS（可编程只读存储器），用于存储计算机的基本设置，例如日期、时间、启动顺序等。</p><blockquote><p>UEFI是一种更新的固件接口，它取代了传统的BIOS。UEFI提供了更先进的功能和更好的兼容性。与BIOS相比，UEFI具有以下优势：</p><ol><li>容量更大：UEFI支持更大的固件容量，可以容纳更多的功能和驱动程序。</li><li>启动速度更快：UEFI的启动速度比BIOS更快，因为它在启动时不需要进行硬件初始化和自检。</li><li>更好的兼容性：UEFI可以更好地与现代操作系统和硬件设备兼容，支持更多的文件系统和硬件接口。</li><li>图形界面：UEFI提供了一个图形界面，使用户可以更直观地设置计算机的启动选项和其他设置。</li></ol></blockquote><p>总的来说，UEFI是一种更先进、更灵活和更可扩展的固件接口，它取代了传统的BIOS，并提供了更好的启动速度和兼容性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HW避雷</title>
      <link href="/2023/09/02/HW%E9%81%BF%E9%9B%B7/"/>
      <url>/2023/09/02/HW%E9%81%BF%E9%9B%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="被坑的护网-HW-HVV-国护-经历-amp-套路分享，保持警惕！"><a href="#被坑的护网-HW-HVV-国护-经历-amp-套路分享，保持警惕！" class="headerlink" title="被坑的护网(HW, HVV, 国护)经历&amp;套路分享，保持警惕！"></a>被坑的护网(HW, HVV, 国护)经历&amp;套路分享，保持警惕！</h1><p><strong>本文系转载，原文链接<a href="https://github.com/venkatorne/HVV_Share/blob/main/HW%E9%81%BF%E9%9B%B7.md" title="被坑的护网(HW, HVV, 国护)经历&amp;套路分享，保持警惕！">https://github.com/venkatorne/HVV_Share&#x2F;blob&#x2F;main&#x2F;HW%E9%81%BF%E9%9B%B7.md</a></strong></p><p>欢迎PR，关键信息请打码或变声，注意不要泄露隐私或恶意破坏他人声誉！<br><br>可不分享真实案例，只提供套路，能少一个师傅被坑都是好事! 欢迎Star与分享，让更多人看到!<br><br><strong>为众人抱薪者，不可使其冻毙于风雪。</strong></p><h1 id="承诺安排项目锁人，最终安排少量夜班工作天数，提出疑问视为拒绝项目"><a href="#承诺安排项目锁人，最终安排少量夜班工作天数，提出疑问视为拒绝项目" class="headerlink" title="承诺安排项目锁人，最终安排少量夜班工作天数，提出疑问视为拒绝项目"></a>承诺安排项目锁人，最终安排少量夜班工作天数，提出疑问视为拒绝项目</h1><h2 id="核心套路"><a href="#核心套路" class="headerlink" title="核心套路"></a>核心套路</h2><p>承诺安排项目，但安排不下去（中介和厂商都有可能），卡在护网前一两天安排项目，每人安排少量夜班工作天数，提出疑问（非明确拒绝）则视为不接受项目，无需承担任何责任！</p><h2 id="极端例子（理论上）"><a href="#极端例子（理论上）" class="headerlink" title="极端例子（理论上）"></a>极端例子（理论上）</h2><ol><li>中介或厂商承诺了项目但人安排不下去，护网15天里一人一天夜班，一个人的工作可以直接安排15人，有疑议（甚至不需要表示拒绝）就视为不接受直接释放，快速的继续安排下个人，且责任在于师傅个人。</li><li>同时中介不包差旅，一天工资甚至不够路费，为了不付费上班，只能明确拒绝项目，中介&#x2F;厂商无责，甚至可能追责师傅个人不服从安排导致项目出现问题进行索赔。</li><li>卡在护网前一天安排项目，让师傅没有选择的余地</li></ol><h2 id="中介可能存在的好处"><a href="#中介可能存在的好处" class="headerlink" title="中介可能存在的好处"></a>中介可能存在的好处</h2><ol><li>可接近无责大量锁人到护网前甚至结束</li><li>优先选择价低的师傅去安排，赚更多中介费，剩下的约等于无责释放</li><li>道德混淆：是师傅嫌弃项目不服从安排，而不是中介&#x2F;厂商不安排，立于道德与法律上的不败之地。<br>（如：甚至都没分配到项目&#x2F;项目黄了都没说，你还嫌天数少，活该！）</li></ol><h2 id="真实案例分享"><a href="#真实案例分享" class="headerlink" title="真实案例分享"></a>真实案例分享</h2><h3 id="涉及对象（只为便于理解，某些人请不要自行代入）"><a href="#涉及对象（只为便于理解，某些人请不要自行代入）" class="headerlink" title="涉及对象（只为便于理解，某些人请不要自行代入）"></a>涉及对象（只为便于理解，某些人请不要自行代入）</h3><ul><li>中介 公司：成都宏*****<em><strong>*公司（可能改名）、统一社会信用代码：915</strong></em>Y2R</li><li>拉群微信：春<strong>（Cl0</strong>***）</li><li>对接人 微信：*刘（xsy**<em>*<em><strong>）、名称：</strong>杰、联系方式：</em>*</em>2712</li><li>厂商：某数字公司</li><li>项目经理(疑似)：*志</li></ul><h3 id="核心时间线"><a href="#核心时间线" class="headerlink" title="核心时间线"></a>核心时间线</h3><ul><li>6.25 发布需求：某数字公司第三批招人，提前进场</li><li>6.25 中介面</li><li>6.27 厂商面</li><li>6.28 中介表示没过提前进场，但厂商锁人，承诺优先安排提前进场按80%算工资，正式护网15天</li><li>6.29 11:29 问询不定岗违约责任，中介表示违约责任是厂商定</li><li>6.29 11:39 厂商人员打电话，中间厂商人员承诺定岗</li><li>6.29 15:08 跟中介签订合同</li><li>7.31 跟中介问询项目分配</li><li>8.7 19:53 （开始前两天晚上） 分配项目进群</li><li>8.7 22:10 跟项目经理确认只能排7天或8天夜班</li><li>8.7 22:12 跟中介问询天数，中介表示他去协调</li><li>8.7 22:22 项目经理突然跟我表示：你考虑下其他项目，我这边没这么多空余人天</li><li>8.7 22:23 截图发给中介，中介表示客户把我pass了，换人了（我跟中介与项目经理均未表示拒绝该项目）</li><li>8.7 22:31 中介表示换项目，需要等明天(8.8日)安排</li><li>8.8 整日未回消息</li><li>8.9 中介表示：你被释放了</li><li>8.9 与中介沟通，索要补偿或安排新项目，被拒绝&#x2F;无视</li><li>8.10 中介踢群+拉黑</li></ul><h3 id="相关证据"><a href="#相关证据" class="headerlink" title="相关证据"></a>相关证据</h3><ul><li>6.25 发布需求：某数字公司第三批招人，提前进场<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/ef25f5ec-7409-4346-be1a-6c72a3d7f45e" width="250"/><br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/a5b43832-97f6-427e-9157-d2c128e2fb64" width="250"/></li><li>6.28 中介表示没过提前进场，但厂商锁人，承诺优先安排提前进场按80%算工资，正式护网15天<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/8a18e7dd-d3d8-48fd-a974-0b01e6c7e722" width="250"/><br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/fe1ac7d1-7860-470f-b865-25063a6276e6" width="250"/></li><li>6.29 11:29 问询不定岗违约责任，中介表示违约责任是厂商定<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/b9a81692-deec-4374-ae4f-7d9c1f8f8ced" width="250"/></li><li>6.29 11:39 厂商人员打电话，中间厂商人员承诺定岗<video controls width="250"><source src="https://github.com/venkatorne/HVV_Share/assets/141924762/0658cb4b-ffc9-4d8d-9244-af9ab3b9508d" type="video/mp4" /></video><br>https://github.com/venkatorne/HVV_Share/assets/141924762/0658cb4b-ffc9-4d8d-9244-af9ab3b9508d</li><li>7.31 跟中介问询项目分配<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/892780b7-4730-4e85-985f-7138aab2736b" width="250"/></li><li>8.7 19:53 （开始前两天晚上） 分配项目进群<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/51f82c54-4cb4-47c7-b240-613a7d0733ea" width="250"/></li><li>8.7 22:10 跟项目经理确认只能排7天或8天夜班<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/e83135cc-b750-4910-a8f8-20a223a1c2fb" width="250"/></li><li>8.7 22:12 跟中介问询天数，中介表示他去协调<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/72a765ff-4617-4179-acc4-258febae754b" width="250"/><br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/e30a0ab0-b2fd-4d0e-8c5f-b369fb290414" width="250"/></li><li>8.7 22:22 项目经理突然跟我表示：你考虑下其他项目，我这边没这么多空余人天<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/e83135cc-b750-4910-a8f8-20a223a1c2fb" width="250"/></li><li>8.7 22:23 截图发给中介，中介表示客户把我pass了，换人了（我跟中介与项目经理均未表示拒绝该项目）</li><li>8.7 22:31 中介表示换项目，需要等明天(8.8日)安排</li><li>8.8 整日未回消息</li><li>8.9 中介表示：你被释放了<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/a34ed097-59f2-45e7-afc4-fad00eef8fa5" width="250"/></li><li>8.10 中介踢群+拉黑<br><br><img src="https://github.com/venkatorne/HVV_Share/assets/141924762/acffba09-9aae-46c6-bb76-b7bb18f4115a" width="250"/></li></ul><h3 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h3><p>整个心态爆炸，恶心坏了：<br><br>面提前进场，结果没提前进场；<br><br>说优先安排提前进场，护网开始前2天才分配项目；<br><br>说好15天，一开排班7天夜班；<br><br>（提前进场赚钱-&gt;只给赚7天钱）；<br><br>中介表示协调，结果我还没说拒绝项目呢，就直接光速换人；<br><br>（只给赚7天钱-&gt;滚）；<br><br>中介说换项目，结果白等一天（护网开始前1天）；<br><br>护网开始第1天跟我说被释放了；<br><br>（滚-&gt;完美浪费掉你找其他项目的时间）；<br><br>要求补偿&#x2F;安排项目，直接被拒绝甚至无视，最终拉黑。<br><br><br>只能说太<strong>牛逼</strong>了，这种活该财源广进！</p><h2 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h2><ol><li>合同约定最少工作天数与保证定岗&#x2F;安排项目</li><li>不要理会任何口头承诺（电话&#x2F;微信聊天），只有写进合同才有效</li><li>约定违约赔偿金额</li><li>不要轻信<code>根据厂商决定</code>&#x2F;<code>按厂商的违约来定</code>的话术，不要轻信厂商承诺</li><li>违约是你跟中介的事，找中介麻烦，中介推脱是厂商责任也要让中介去找厂商，不要自己去找厂商</li><li><strong>避雷特定中介</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HW </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成为未来的管理者之前的笔记</title>
      <link href="/2023/09/01/%E6%88%90%E4%B8%BA%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E4%B9%8B%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/01/%E6%88%90%E4%B8%BA%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E4%B9%8B%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="成为未来的管理者之前的笔记"><a href="#成为未来的管理者之前的笔记" class="headerlink" title="成为未来的管理者之前的笔记"></a>成为未来的管理者之前的笔记</h1><ul><li><p>不辞退不够强的人，是对其他正在付出的人的不尊重</p></li><li><p>盲目换人从来不解决本质问题</p></li><li><p><strong>有效量化</strong>，降低信息差，是企业运作的核心</p><blockquote><ol><li>搭建适合自己的信息系统<em>（工具：飞书、共享文档）</em></li><li>会议优化（具体执行方法：在开会之前采用协作文档，共同记录信息；会议开始后，所有人静默10min阅读文档，有疑点的地方直接批注，在线交流；之后的会议只讨论批注的问题。目的：压缩会议时长，避免侃大山，减小部门间的信息差）</li></ol></blockquote></li><li><p>人性是经不起挑战的，商业，是切蛋糕的艺术，即<strong>利益分配要合理</strong></p></li><li><p>OKR体系：全称是 Objectives &amp; Key Results，即目标与关键成果。</p><blockquote><ol><li>O是努力的方向和目标，概念意义上的，代表你到底要去哪里</li><li>KR是理想结果，必须可量化，具体到面向个人，代表具体怎么去</li></ol><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/265830351" title="一分钟让你明白OKR考核">https://zhuanlan.zhihu.com/p/265830351</a></p></blockquote></li><li><p>内容创作者不要把自己当回事<em>（对于内容创作者需要知道的行业规则之一：和代理有效沟通“返点”问题）</em></p></li><li><p>一个优秀的视频应当具备的要素：HKRR（H：Happiness，K：Knowledge，R：Resonance，R：Rhythm）</p></li><li><p>电影行业的技巧————<strong>时钟理论</strong>：将视频的时长作为圆的周长，标出0点、3点、6点、9点的内容，如果这四个点没有爆点，那么必须修改，尽可能让刺激点充满整个时钟。目的：<strong>可视化视频节奏</strong></p></li><li><p>不融资的话，团队人数上限不应超过20人</p></li></ul><p><strong>不要留恋成功的一刻，不要躺在功劳簿上享福</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全成长路径</title>
      <link href="/2023/08/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84/"/>
      <url>/2023/08/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="网络安全成长路径"><a href="#网络安全成长路径" class="headerlink" title="网络安全成长路径"></a>网络安全成长路径</h1><ol><li>学习“小迪安全-渗透测试”的课程</li><li>考证：软考（中级信息安全工程师）、CISP（CISP-PTE、CISP-PTS）、OSCP</li><li>获取CNVD证书</li><li>SRC平台挖漏洞</li><li>写一个GitHub项目</li><li>搭建一个blog站，记录学习过程与经历，如记一次XXX或记一次XXX到XXX</li><li>参加CTF比赛</li></ol><p>参考链接：<a href="https://blog.csdn.net/m0_67286096/article/details/124020811" title="网络安全攻防五件套，OCSP、CISP-PTE、CISP-PTS、CISP-IRE、CISP-IRS">https://blog.csdn.net/m0_67286096&#x2F;article&#x2F;details&#x2F;124020811</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD的常见符号及其作用</title>
      <link href="/2023/08/30/CMD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AC%A6%E5%8F%B7%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/08/30/CMD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AC%A6%E5%8F%B7%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Q：<code>tasklist | findstr &quot;cmd&quot;</code>此命令中的“|”是什么作用？</p><p>A：在CMD中，”|”（管道符号）的作用是<strong>将前一个命令的输出作为后一个命令的输入</strong>。在给出的命令中，”tasklist”命令用于列出当前正在运行的进程列表，而”findstr”命令用于在输出结果中查找包含指定字符串（在此例中是”cmd”）的行。所以整个命令的作用是列出当前正在运行的进程列表，并在结果中筛选出包含”cmd”字符串的行。</p><h2 id="CMD的常见符号及其作用-："><a href="#CMD的常见符号及其作用-：" class="headerlink" title="CMD的常见符号及其作用 ："></a>CMD的常见符号及其作用 ：</h2><ol><li><strong>“&gt;”：重定向符号。用于将命令的输出重定向到文件</strong>。例如，”dir &gt; output.txt”将”dir”命令的输出保存到名为”output.txt”的文件中。</li><li><strong>“&gt;&gt;”：追加重定向符号。与”&gt;”类似，但是会将命令的输出追加到文件的末尾，而不是覆盖文件内容</strong>。</li><li><strong>“&lt;”：输入重定向符号。用于将文件中的内容作为命令的输入</strong>。例如，”sort &lt; input.txt”将”input.txt”文件中的内容作为”sort”命令的输入进行排序。</li><li><strong>“&amp;”：命令分隔符。用于在一行中运行多个命令</strong>。例如，”command1 &amp; command2”将依次执行”command1”和”command2”。</li><li><strong>“&amp;&amp;”：条件命令分隔符。只有前一个命令成功执行后，才会执行后续的命令</strong>。例如，”command1 &amp;&amp; command2”只有在”command1”成功执行后，才会执行”command2”。</li><li><strong>“||”：条件命令分隔符。只有前一个命令执行失败后，才会执行后续的命令</strong>。例如，”command1 || command2”只有在”command1”执行失败后，才会执行”command2”。</li></ol><p>这些符号可以帮助您在CMD下更有效地执行命令和操作。请注意，有些符号在不同的操作系统或命令行环境中可能会有不同的行为。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同操作系统对待换行符的不同态度</title>
      <link href="/2023/08/29/%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%BE%85%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%80%81%E5%BA%A6/"/>
      <url>/2023/08/29/%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%BE%85%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%80%81%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>不同操作系统对待换行符的主要区别在于使用的字符不同。</p><p>在Windows操作系统中，换行符由两个字符组成：回车符（CR）和换行符（LF），表示为”\r\n”。</p><p>在Unix&#x2F;Linux操作系统中，换行符只有一个字符：换行符（LF），表示为”\n”。</p><p>在Macintosh操作系统中，换行符只有一个字符：回车符（CR），表示为”\r”。</p><p>这些差异可能会导致在不同操作系统之间传输文本文件时出现格式问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每天一个小知识点 </tag>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DoS压力测试工具——Slowhttptest</title>
      <link href="/2023/08/28/DoS%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Slowhttptest/"/>
      <url>/2023/08/28/DoS%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Slowhttptest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="DoS压力测试工具——Slowhttptest"><a href="#DoS压力测试工具——Slowhttptest" class="headerlink" title="DoS压力测试工具——Slowhttptest"></a>DoS压力测试工具——Slowhttptest</h1><p>安装命令：<code>apt-get install slowhttptest </code></p><p>使用方法：<code>ulimit -n 8000 &amp;&amp; slowhttptest -c 8000 -X -r 100 -g -o / -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://caichuanqi.cn -p 3</code></p><p>参考链接：<a href="https://caichuanqi.blog.csdn.net/article/details/124744284" title="Kali Linux 安装slowhttptest步骤">https://caichuanqi.blog.csdn.net/article/details/124744284</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器上基于Docker搭建AWVS教程</title>
      <link href="/2023/07/09/AWVS%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2023/07/09/AWVS%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="第0步：系统更新"><a href="#第0步：系统更新" class="headerlink" title="第0步：系统更新"></a>第0步：系统更新</h2><p>笔者使用的Linux系统是Debian 11.1 64bit。</p><p>切换到root用户，并且注意全程使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>更新软件包列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>进行一次升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="第1步：安装Docker"><a href="#第1步：安装Docker" class="headerlink" title="第1步：安装Docker"></a>第1步：安装Docker</h2><p>安装docker和docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker docker-compose</span><br></pre></td></tr></table></figure><p>安装Docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><p>安装完成后使用如下命令检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h2 id="第2步：安装AWVS"><a href="#第2步：安装AWVS" class="headerlink" title="第2步：安装AWVS"></a>第2步：安装AWVS</h2><p>拉取Docker镜像<br><img src="https://s2.loli.net/2023/07/09/ik2gua81tYsdnez.png" alt="docker pull.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/hiepnv/acunetix</span><br></pre></td></tr></table></figure><p>创建名为acunetix_data的Docker卷<br><img src="https://s2.loli.net/2023/07/09/TObiGQlW8vo3rf4.png" alt="docker volume create acunetix_data.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create acunetix_data</span><br></pre></td></tr></table></figure><p>运行acunetix_web的容器<br><img src="https://s2.loli.net/2023/07/09/xAPJfi784yjDzX1.png" alt="docker run -d -p.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3443:3443 --restart=unless-stoped --name=acunetix_web quay.io/hiepnv/acunetix</span><br></pre></td></tr></table></figure><h2 id="第3步：开放端口"><a href="#第3步：开放端口" class="headerlink" title="第3步：开放端口"></a>第3步：开放端口</h2><p>云服务器防火墙开放端口，个人使用可以全部开放，如有必要则可以选择只开放3443端口<br><img src="https://s2.loli.net/2023/07/09/g3LKOcMdj9vH6Yp.png" alt="防火墙开放端口.png"></p><h2 id="第4步：测试"><a href="#第4步：测试" class="headerlink" title="第4步：测试"></a>第4步：测试</h2><p><strong>必须通过HTTPS访问3443端口</strong></p><p>默认账户：<a href="mailto:&#x61;&#100;&#x6d;&#105;&#x6e;&#64;&#x61;&#x63;&#117;&#x2e;&#x63;&#111;&#109;">&#x61;&#100;&#x6d;&#105;&#x6e;&#64;&#x61;&#x63;&#117;&#x2e;&#x63;&#111;&#109;</a></p><p>默认密码：Passw0rd!</p>]]></content>
      
      
      
        <tags>
            
            <tag> AWVS </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo框架搭建个人博客教程</title>
      <link href="/2023/06/17/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2023/06/17/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>本文前置技能：虚拟机的安装与初始化，Linux操作系统基础</strong></p><h2 id="第0步：系统更新"><a href="#第0步：系统更新" class="headerlink" title="第0步：系统更新"></a>第0步：系统更新</h2><p>笔者使用的Linux系统是Ubuntu LTS22.0.4。所有使用Debian内核的Linux都可遵循本教程。</p><p>切换到root用户，并且注意全程使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>更新软件包列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>进行一次升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="第1步：安装Git"><a href="#第1步：安装Git" class="headerlink" title="第1步：安装Git"></a>第1步：安装Git</h2><p>注意使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><p>安装完成后使用如下命令检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="第2步：安装Nodejs"><a href="#第2步：安装Nodejs" class="headerlink" title="第2步：安装Nodejs"></a>第2步：安装Nodejs</h2><p>注意使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install node</span><br><span class="line">apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完成后使用如下命令检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="第3步：安装及初始化Hexo"><a href="#第3步：安装及初始化Hexo" class="headerlink" title="第3步：安装及初始化Hexo"></a>第3步：安装及初始化Hexo</h2><p>注意使用root用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后使用如下命令检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>初始化Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在终端中右键打开链接<a href="http://localhost:4000/">http://localhost:4000/</a>打开Hexo生成的默认网页<br><img src="https://s2.loli.net/2023/06/17/TWuc5B1r8a2SjVL.png" alt="localhost:4000"></p><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/15/hello-world/"/>
      <url>/2023/06/15/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
